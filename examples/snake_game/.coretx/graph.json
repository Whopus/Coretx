{
  "project_path": "/workspace/Coretx/examples/snake_game",
  "entities": [
    {
      "id": "module:ai_player.py:ai_player:1",
      "type": "module",
      "name": "ai_player",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 1,
      "line_end": 276,
      "description": "AI Player for Snake Game\nImplements different AI strategies for playing the snake game automatically.",
      "content": "\"\"\"\nAI Player for Snake Game\nImplements different AI strategies for playing the snake game automatically.\n\"\"\"\n\nimport random\nfrom typing import List, Optional, Tuple\nfrom enum import Enum\nfrom game import Snake, Food, Direction, Position\nfrom utils import PathFinder\n\n\nclass AIStrategy(Enum):\n    \"\"\"Different AI strategies for playing the game.\"\"\"\n    RANDOM = \"random\"\n    GREEDY = \"greedy\"\n    PATHFINDING = \"pathfinding\"\n    HAMILTONIAN = \"hamiltonian\"\n\n\nclass AIPlayer:\n    \"\"\"Base class for AI players.\"\"\"\n    \n    def __init__(self, strategy: AIStrategy = AIStrategy.GREEDY):\n        self.strategy = strategy\n        self.moves_made = 0\n        self.successful_moves = 0\n    \n    def get_next_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Get the next move for the AI player.\"\"\"\n        self.moves_made += 1\n        \n        if self.strategy == AIStrategy.RANDOM:\n            return self._random_move(snake)\n        elif self.strategy == AIStrategy.GREEDY:\n            return self._greedy_move(snake, food, grid_width, grid_height)\n        elif self.strategy == AIStrategy.PATHFINDING:\n            return self._pathfinding_move(snake, food, grid_width, grid_height)\n        elif self.strategy == AIStrategy.HAMILTONIAN:\n            return self._hamiltonian_move(snake, food, grid_width, grid_height)\n        else:\n            return self._greedy_move(snake, food, grid_width, grid_height)\n    \n    def _random_move(self, snake: Snake) -> Direction:\n        \"\"\"Make a random valid move.\"\"\"\n        possible_directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT]\n        \n        # Remove opposite direction to prevent immediate collision\n        opposite_directions = {\n            Direction.UP: Direction.DOWN,\n            Direction.DOWN: Direction.UP,\n            Direction.LEFT: Direction.RIGHT,\n            Direction.RIGHT: Direction.LEFT\n        }\n        \n        opposite = opposite_directions.get(snake.direction)\n        if opposite in possible_directions:\n            possible_directions.remove(opposite)\n        \n        return random.choice(possible_directions)\n    \n    def _greedy_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Move greedily towards food while avoiding collisions.\"\"\"\n        head = snake.get_head_position()\n        food_pos = food.position\n        \n        # Calculate direction towards food\n        dx = food_pos.x - head.x\n        dy = food_pos.y - head.y\n        \n        # Prioritize directions based on distance to food\n        preferred_directions = []\n        \n        if abs(dx) > abs(dy):\n            # Horizontal movement is more important\n            if dx > 0:\n                preferred_directions.append(Direction.RIGHT)\n            elif dx < 0:\n                preferred_directions.append(Direction.LEFT)\n            \n            if dy > 0:\n                preferred_directions.append(Direction.DOWN)\n            elif dy < 0:\n                preferred_directions.append(Direction.UP)\n        else:\n            # Vertical movement is more important\n            if dy > 0:\n                preferred_directions.append(Direction.DOWN)\n            elif dy < 0:\n                preferred_directions.append(Direction.UP)\n            \n            if dx > 0:\n                preferred_directions.append(Direction.RIGHT)\n            elif dx < 0:\n                preferred_directions.append(Direction.LEFT)\n        \n        # Add remaining directions\n        all_directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT]\n        for direction in all_directions:\n            if direction not in preferred_directions:\n                preferred_directions.append(direction)\n        \n        # Choose first safe direction\n        for direction in preferred_directions:\n            if self._is_safe_move(snake, direction, grid_width, grid_height):\n                return direction\n        \n        # If no safe move found, return current direction (will likely cause game over)\n        return snake.direction\n    \n    def _pathfinding_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Use pathfinding to navigate to food.\"\"\"\n        head = snake.get_head_position()\n        snake_body = snake.get_body_positions()\n        \n        # Find path to food\n        path = PathFinder.find_path_to_food(head, food.position, snake_body, grid_width, grid_height)\n        \n        if path:\n            next_pos = path[0]\n            return self._get_direction_to_position(head, next_pos)\n        else:\n            # Fallback to greedy if no path found\n            return self._greedy_move(snake, food, grid_width, grid_height)\n    \n    def _hamiltonian_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Use Hamiltonian cycle strategy (simplified version).\"\"\"\n        # This is a simplified version - a full Hamiltonian cycle would be more complex\n        head = snake.get_head_position()\n        \n        # Try to follow a pattern that covers the entire grid\n        if head.x % 2 == 0:\n            # Even columns: go down when possible, right when at bottom\n            if head.y < grid_height - 1:\n                if self._is_safe_move(snake, Direction.DOWN, grid_width, grid_height):\n                    return Direction.DOWN\n            if head.x < grid_width - 1:\n                if self._is_safe_move(snake, Direction.RIGHT, grid_width, grid_height):\n                    return Direction.RIGHT\n        else:\n            # Odd columns: go up when possible, right when at top\n            if head.y > 0:\n                if self._is_safe_move(snake, Direction.UP, grid_width, grid_height):\n                    return Direction.UP\n            if head.x < grid_width - 1:\n                if self._is_safe_move(snake, Direction.RIGHT, grid_width, grid_height):\n                    return Direction.RIGHT\n        \n        # Fallback to greedy\n        return self._greedy_move(snake, food, grid_width, grid_height)\n    \n    def _is_safe_move(self, snake: Snake, direction: Direction, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Check if a move in the given direction is safe.\"\"\"\n        head = snake.get_head_position()\n        direction_offset = Position(*direction.value)\n        new_head = head + direction_offset\n        \n        # Check wall collision\n        if (new_head.x < 0 or new_head.x >= grid_width or \n            new_head.y < 0 or new_head.y >= grid_height):\n            return False\n        \n        # Check self collision (excluding tail which will move)\n        snake_body = snake.get_body_positions()[:-1]  # Exclude tail\n        if new_head in snake_body:\n            return False\n        \n        return True\n    \n    def _get_direction_to_position(self, from_pos: Position, to_pos: Position) -> Direction:\n        \"\"\"Get direction from one position to another.\"\"\"\n        dx = to_pos.x - from_pos.x\n        dy = to_pos.y - from_pos.y\n        \n        if dx > 0:\n            return Direction.RIGHT\n        elif dx < 0:\n            return Direction.LEFT\n        elif dy > 0:\n            return Direction.DOWN\n        elif dy < 0:\n            return Direction.UP\n        else:\n            return Direction.RIGHT  # Default\n    \n    def get_performance_stats(self) -> dict:\n        \"\"\"Get AI performance statistics.\"\"\"\n        success_rate = self.successful_moves / max(1, self.moves_made)\n        return {\n            \"moves_made\": self.moves_made,\n            \"successful_moves\": self.successful_moves,\n            \"success_rate\": success_rate,\n            \"strategy\": self.strategy.value\n        }\n    \n    def reset_stats(self) -> None:\n        \"\"\"Reset performance statistics.\"\"\"\n        self.moves_made = 0\n        self.successful_moves = 0\n\n\nclass AdvancedAI(AIPlayer):\n    \"\"\"Advanced AI with learning capabilities and multiple strategies.\"\"\"\n    \n    def __init__(self):\n        super().__init__(AIStrategy.PATHFINDING)\n        self.strategy_performance = {\n            AIStrategy.GREEDY: {\"score\": 0, \"games\": 0},\n            AIStrategy.PATHFINDING: {\"score\": 0, \"games\": 0},\n            AIStrategy.HAMILTONIAN: {\"score\": 0, \"games\": 0}\n        }\n        self.current_strategy = AIStrategy.PATHFINDING\n        self.adaptation_threshold = 5  # Games before considering strategy change\n    \n    def get_next_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Get next move using adaptive strategy selection.\"\"\"\n        # Use current strategy\n        old_strategy = self.strategy\n        self.strategy = self.current_strategy\n        move = super().get_next_move(snake, food, grid_width, grid_height)\n        self.strategy = old_strategy\n        \n        return move\n    \n    def record_game_result(self, strategy: AIStrategy, score: int) -> None:\n        \"\"\"Record the result of a game for strategy evaluation.\"\"\"\n        if strategy in self.strategy_performance:\n            self.strategy_performance[strategy][\"score\"] += score\n            self.strategy_performance[strategy][\"games\"] += 1\n            \n            # Adapt strategy if enough games played\n            if self.strategy_performance[strategy][\"games\"] >= self.adaptation_threshold:\n                self._adapt_strategy()\n    \n    def _adapt_strategy(self) -> None:\n        \"\"\"Adapt strategy based on performance.\"\"\"\n        best_strategy = self.current_strategy\n        best_avg_score = 0\n        \n        for strategy, stats in self.strategy_performance.items():\n            if stats[\"games\"] > 0:\n                avg_score = stats[\"score\"] / stats[\"games\"]\n                if avg_score > best_avg_score:\n                    best_avg_score = avg_score\n                    best_strategy = strategy\n        \n        self.current_strategy = best_strategy\n    \n    def get_strategy_stats(self) -> dict:\n        \"\"\"Get statistics for all strategies.\"\"\"\n        stats = {}\n        for strategy, data in self.strategy_performance.items():\n            avg_score = data[\"score\"] / max(1, data[\"games\"])\n            stats[strategy.value] = {\n                \"games_played\": data[\"games\"],\n                \"total_score\": data[\"score\"],\n                \"average_score\": avg_score\n            }\n        return stats\n\n\ndef create_ai_player(difficulty: str = \"medium\") -> AIPlayer:\n    \"\"\"Factory function to create AI players of different difficulties.\"\"\"\n    difficulty_map = {\n        \"easy\": AIStrategy.RANDOM,\n        \"medium\": AIStrategy.GREEDY,\n        \"hard\": AIStrategy.PATHFINDING,\n        \"expert\": AIStrategy.HAMILTONIAN\n    }\n    \n    strategy = difficulty_map.get(difficulty.lower(), AIStrategy.GREEDY)\n    \n    if difficulty.lower() == \"adaptive\":\n        return AdvancedAI()\n    else:\n        return AIPlayer(strategy)",
      "language": "python",
      "metadata": {
        "is_package": false,
        "line_count": 276
      },
      "embedding": null
    },
    {
      "id": "import:ai_player.py:import random:6",
      "type": "import",
      "name": "import random",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 6,
      "line_end": 6,
      "description": "",
      "content": "import random",
      "language": "python",
      "metadata": {
        "imported_names": [
          "random"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:ai_player.py:from typing import List, Optional, Tuple:7",
      "type": "import",
      "name": "from typing import List, Optional, Tuple",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 7,
      "line_end": 7,
      "description": "",
      "content": "from typing import List, Optional, Tuple",
      "language": "python",
      "metadata": {
        "imported_names": [
          "List",
          "Optional",
          "Tuple"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:ai_player.py:from enum import Enum:8",
      "type": "import",
      "name": "from enum import Enum",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 8,
      "line_end": 8,
      "description": "",
      "content": "from enum import Enum",
      "language": "python",
      "metadata": {
        "imported_names": [
          "Enum"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:ai_player.py:from game import Snake, Food, Direction, Position:9",
      "type": "import",
      "name": "from game import Snake, Food, Direction, Position",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 9,
      "line_end": 9,
      "description": "",
      "content": "from game import Snake, Food, Direction, Position",
      "language": "python",
      "metadata": {
        "imported_names": [
          "Snake",
          "Food",
          "Direction",
          "Position"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:ai_player.py:from utils import PathFinder:10",
      "type": "import",
      "name": "from utils import PathFinder",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 10,
      "line_end": 10,
      "description": "",
      "content": "from utils import PathFinder",
      "language": "python",
      "metadata": {
        "imported_names": [
          "PathFinder"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIStrategy:13",
      "type": "class",
      "name": "AIStrategy",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 13,
      "line_end": 18,
      "description": "Different AI strategies for playing the game.",
      "content": "class AIStrategy(Enum):\n    \"\"\"Different AI strategies for playing the game.\"\"\"\n    RANDOM = \"random\"\n    GREEDY = \"greedy\"\n    PATHFINDING = \"pathfinding\"\n    HAMILTONIAN = \"hamiltonian\"",
      "language": "python",
      "metadata": {
        "base_classes": [
          "Enum"
        ],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21",
      "type": "class",
      "name": "AIPlayer",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 21,
      "line_end": 199,
      "description": "Base class for AI players.",
      "content": "class AIPlayer:\n    \"\"\"Base class for AI players.\"\"\"\n    \n    def __init__(self, strategy: AIStrategy = AIStrategy.GREEDY):\n        self.strategy = strategy\n        self.moves_made = 0\n        self.successful_moves = 0\n    \n    def get_next_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Get the next move for the AI player.\"\"\"\n        self.moves_made += 1\n        \n        if self.strategy == AIStrategy.RANDOM:\n            return self._random_move(snake)\n        elif self.strategy == AIStrategy.GREEDY:\n            return self._greedy_move(snake, food, grid_width, grid_height)\n        elif self.strategy == AIStrategy.PATHFINDING:\n            return self._pathfinding_move(snake, food, grid_width, grid_height)\n        elif self.strategy == AIStrategy.HAMILTONIAN:\n            return self._hamiltonian_move(snake, food, grid_width, grid_height)\n        else:\n            return self._greedy_move(snake, food, grid_width, grid_height)\n    \n    def _random_move(self, snake: Snake) -> Direction:\n        \"\"\"Make a random valid move.\"\"\"\n        possible_directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT]\n        \n        # Remove opposite direction to prevent immediate collision\n        opposite_directions = {\n            Direction.UP: Direction.DOWN,\n            Direction.DOWN: Direction.UP,\n            Direction.LEFT: Direction.RIGHT,\n            Direction.RIGHT: Direction.LEFT\n        }\n        \n        opposite = opposite_directions.get(snake.direction)\n        if opposite in possible_directions:\n            possible_directions.remove(opposite)\n        \n        return random.choice(possible_directions)\n    \n    def _greedy_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Move greedily towards food while avoiding collisions.\"\"\"\n        head = snake.get_head_position()\n        food_pos = food.position\n        \n        # Calculate direction towards food\n        dx = food_pos.x - head.x\n        dy = food_pos.y - head.y\n        \n        # Prioritize directions based on distance to food\n        preferred_directions = []\n        \n        if abs(dx) > abs(dy):\n            # Horizontal movement is more important\n            if dx > 0:\n                preferred_directions.append(Direction.RIGHT)\n            elif dx < 0:\n                preferred_directions.append(Direction.LEFT)\n            \n            if dy > 0:\n                preferred_directions.append(Direction.DOWN)\n            elif dy < 0:\n                preferred_directions.append(Direction.UP)\n        else:\n            # Vertical movement is more important\n            if dy > 0:\n                preferred_directions.append(Direction.DOWN)\n            elif dy < 0:\n                preferred_directions.append(Direction.UP)\n            \n            if dx > 0:\n                preferred_directions.append(Direction.RIGHT)\n            elif dx < 0:\n                preferred_directions.append(Direction.LEFT)\n        \n        # Add remaining directions\n        all_directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT]\n        for direction in all_directions:\n            if direction not in preferred_directions:\n                preferred_directions.append(direction)\n        \n        # Choose first safe direction\n        for direction in preferred_directions:\n            if self._is_safe_move(snake, direction, grid_width, grid_height):\n                return direction\n        \n        # If no safe move found, return current direction (will likely cause game over)\n        return snake.direction\n    \n    def _pathfinding_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Use pathfinding to navigate to food.\"\"\"\n        head = snake.get_head_position()\n        snake_body = snake.get_body_positions()\n        \n        # Find path to food\n        path = PathFinder.find_path_to_food(head, food.position, snake_body, grid_width, grid_height)\n        \n        if path:\n            next_pos = path[0]\n            return self._get_direction_to_position(head, next_pos)\n        else:\n            # Fallback to greedy if no path found\n            return self._greedy_move(snake, food, grid_width, grid_height)\n    \n    def _hamiltonian_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Use Hamiltonian cycle strategy (simplified version).\"\"\"\n        # This is a simplified version - a full Hamiltonian cycle would be more complex\n        head = snake.get_head_position()\n        \n        # Try to follow a pattern that covers the entire grid\n        if head.x % 2 == 0:\n            # Even columns: go down when possible, right when at bottom\n            if head.y < grid_height - 1:\n                if self._is_safe_move(snake, Direction.DOWN, grid_width, grid_height):\n                    return Direction.DOWN\n            if head.x < grid_width - 1:\n                if self._is_safe_move(snake, Direction.RIGHT, grid_width, grid_height):\n                    return Direction.RIGHT\n        else:\n            # Odd columns: go up when possible, right when at top\n            if head.y > 0:\n                if self._is_safe_move(snake, Direction.UP, grid_width, grid_height):\n                    return Direction.UP\n            if head.x < grid_width - 1:\n                if self._is_safe_move(snake, Direction.RIGHT, grid_width, grid_height):\n                    return Direction.RIGHT\n        \n        # Fallback to greedy\n        return self._greedy_move(snake, food, grid_width, grid_height)\n    \n    def _is_safe_move(self, snake: Snake, direction: Direction, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Check if a move in the given direction is safe.\"\"\"\n        head = snake.get_head_position()\n        direction_offset = Position(*direction.value)\n        new_head = head + direction_offset\n        \n        # Check wall collision\n        if (new_head.x < 0 or new_head.x >= grid_width or \n            new_head.y < 0 or new_head.y >= grid_height):\n            return False\n        \n        # Check self collision (excluding tail which will move)\n        snake_body = snake.get_body_positions()[:-1]  # Exclude tail\n        if new_head in snake_body:\n            return False\n        \n        return True\n    \n    def _get_direction_to_position(self, from_pos: Position, to_pos: Position) -> Direction:\n        \"\"\"Get direction from one position to another.\"\"\"\n        dx = to_pos.x - from_pos.x\n        dy = to_pos.y - from_pos.y\n        \n        if dx > 0:\n            return Direction.RIGHT\n        elif dx < 0:\n            return Direction.LEFT\n        elif dy > 0:\n            return Direction.DOWN\n        elif dy < 0:\n            return Direction.UP\n        else:\n            return Direction.RIGHT  # Default\n    \n    def get_performance_stats(self) -> dict:\n        \"\"\"Get AI performance statistics.\"\"\"\n        success_rate = self.successful_moves / max(1, self.moves_made)\n        return {\n            \"moves_made\": self.moves_made,\n            \"successful_moves\": self.successful_moves,\n            \"success_rate\": success_rate,\n            \"strategy\": self.strategy.value\n        }\n    \n    def reset_stats(self) -> None:\n        \"\"\"Reset performance statistics.\"\"\"\n        self.moves_made = 0\n        self.successful_moves = 0",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:__init__:24",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 24,
      "line_end": 27,
      "description": "Python method: __init__",
      "content": "def __init__(self, strategy: AIStrategy = AIStrategy.GREEDY):\n        self.strategy = strategy\n        self.moves_made = 0\n        self.successful_moves = 0",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:get_next_move:29",
      "type": "method",
      "name": "get_next_move",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 29,
      "line_end": 42,
      "description": "Get the next move for the AI player.",
      "content": "def get_next_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Get the next move for the AI player.\"\"\"\n        self.moves_made += 1\n        \n        if self.strategy == AIStrategy.RANDOM:\n            return self._random_move(snake)\n        elif self.strategy == AIStrategy.GREEDY:\n            return self._greedy_move(snake, food, grid_width, grid_height)\n        elif self.strategy == AIStrategy.PATHFINDING:\n            return self._pathfinding_move(snake, food, grid_width, grid_height)\n        elif self.strategy == AIStrategy.HAMILTONIAN:\n            return self._hamiltonian_move(snake, food, grid_width, grid_height)\n        else:\n            return self._greedy_move(snake, food, grid_width, grid_height)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:_random_move:44",
      "type": "method",
      "name": "_random_move",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 44,
      "line_end": 60,
      "description": "Make a random valid move.",
      "content": "def _random_move(self, snake: Snake) -> Direction:\n        \"\"\"Make a random valid move.\"\"\"\n        possible_directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT]\n        \n        # Remove opposite direction to prevent immediate collision\n        opposite_directions = {\n            Direction.UP: Direction.DOWN,\n            Direction.DOWN: Direction.UP,\n            Direction.LEFT: Direction.RIGHT,\n            Direction.RIGHT: Direction.LEFT\n        }\n        \n        opposite = opposite_directions.get(snake.direction)\n        if opposite in possible_directions:\n            possible_directions.remove(opposite)\n        \n        return random.choice(possible_directions)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:_greedy_move:62",
      "type": "method",
      "name": "_greedy_move",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 62,
      "line_end": 109,
      "description": "Move greedily towards food while avoiding collisions.",
      "content": "def _greedy_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Move greedily towards food while avoiding collisions.\"\"\"\n        head = snake.get_head_position()\n        food_pos = food.position\n        \n        # Calculate direction towards food\n        dx = food_pos.x - head.x\n        dy = food_pos.y - head.y\n        \n        # Prioritize directions based on distance to food\n        preferred_directions = []\n        \n        if abs(dx) > abs(dy):\n            # Horizontal movement is more important\n            if dx > 0:\n                preferred_directions.append(Direction.RIGHT)\n            elif dx < 0:\n                preferred_directions.append(Direction.LEFT)\n            \n            if dy > 0:\n                preferred_directions.append(Direction.DOWN)\n            elif dy < 0:\n                preferred_directions.append(Direction.UP)\n        else:\n            # Vertical movement is more important\n            if dy > 0:\n                preferred_directions.append(Direction.DOWN)\n            elif dy < 0:\n                preferred_directions.append(Direction.UP)\n            \n            if dx > 0:\n                preferred_directions.append(Direction.RIGHT)\n            elif dx < 0:\n                preferred_directions.append(Direction.LEFT)\n        \n        # Add remaining directions\n        all_directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT]\n        for direction in all_directions:\n            if direction not in preferred_directions:\n                preferred_directions.append(direction)\n        \n        # Choose first safe direction\n        for direction in preferred_directions:\n            if self._is_safe_move(snake, direction, grid_width, grid_height):\n                return direction\n        \n        # If no safe move found, return current direction (will likely cause game over)\n        return snake.direction",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:_pathfinding_move:111",
      "type": "method",
      "name": "_pathfinding_move",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 111,
      "line_end": 124,
      "description": "Use pathfinding to navigate to food.",
      "content": "def _pathfinding_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Use pathfinding to navigate to food.\"\"\"\n        head = snake.get_head_position()\n        snake_body = snake.get_body_positions()\n        \n        # Find path to food\n        path = PathFinder.find_path_to_food(head, food.position, snake_body, grid_width, grid_height)\n        \n        if path:\n            next_pos = path[0]\n            return self._get_direction_to_position(head, next_pos)\n        else:\n            # Fallback to greedy if no path found\n            return self._greedy_move(snake, food, grid_width, grid_height)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:_hamiltonian_move:126",
      "type": "method",
      "name": "_hamiltonian_move",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 126,
      "line_end": 150,
      "description": "Use Hamiltonian cycle strategy (simplified version).",
      "content": "def _hamiltonian_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Use Hamiltonian cycle strategy (simplified version).\"\"\"\n        # This is a simplified version - a full Hamiltonian cycle would be more complex\n        head = snake.get_head_position()\n        \n        # Try to follow a pattern that covers the entire grid\n        if head.x % 2 == 0:\n            # Even columns: go down when possible, right when at bottom\n            if head.y < grid_height - 1:\n                if self._is_safe_move(snake, Direction.DOWN, grid_width, grid_height):\n                    return Direction.DOWN\n            if head.x < grid_width - 1:\n                if self._is_safe_move(snake, Direction.RIGHT, grid_width, grid_height):\n                    return Direction.RIGHT\n        else:\n            # Odd columns: go up when possible, right when at top\n            if head.y > 0:\n                if self._is_safe_move(snake, Direction.UP, grid_width, grid_height):\n                    return Direction.UP\n            if head.x < grid_width - 1:\n                if self._is_safe_move(snake, Direction.RIGHT, grid_width, grid_height):\n                    return Direction.RIGHT\n        \n        # Fallback to greedy\n        return self._greedy_move(snake, food, grid_width, grid_height)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:_is_safe_move:152",
      "type": "method",
      "name": "_is_safe_move",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 152,
      "line_end": 168,
      "description": "Check if a move in the given direction is safe.",
      "content": "def _is_safe_move(self, snake: Snake, direction: Direction, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Check if a move in the given direction is safe.\"\"\"\n        head = snake.get_head_position()\n        direction_offset = Position(*direction.value)\n        new_head = head + direction_offset\n        \n        # Check wall collision\n        if (new_head.x < 0 or new_head.x >= grid_width or \n            new_head.y < 0 or new_head.y >= grid_height):\n            return False\n        \n        # Check self collision (excluding tail which will move)\n        snake_body = snake.get_body_positions()[:-1]  # Exclude tail\n        if new_head in snake_body:\n            return False\n        \n        return True",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:_get_direction_to_position:170",
      "type": "method",
      "name": "_get_direction_to_position",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 170,
      "line_end": 184,
      "description": "Get direction from one position to another.",
      "content": "def _get_direction_to_position(self, from_pos: Position, to_pos: Position) -> Direction:\n        \"\"\"Get direction from one position to another.\"\"\"\n        dx = to_pos.x - from_pos.x\n        dy = to_pos.y - from_pos.y\n        \n        if dx > 0:\n            return Direction.RIGHT\n        elif dx < 0:\n            return Direction.LEFT\n        elif dy > 0:\n            return Direction.DOWN\n        elif dy < 0:\n            return Direction.UP\n        else:\n            return Direction.RIGHT  # Default",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:get_performance_stats:186",
      "type": "method",
      "name": "get_performance_stats",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 186,
      "line_end": 194,
      "description": "Get AI performance statistics.",
      "content": "def get_performance_stats(self) -> dict:\n        \"\"\"Get AI performance statistics.\"\"\"\n        success_rate = self.successful_moves / max(1, self.moves_made)\n        return {\n            \"moves_made\": self.moves_made,\n            \"successful_moves\": self.successful_moves,\n            \"success_rate\": success_rate,\n            \"strategy\": self.strategy.value\n        }",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:reset_stats:196",
      "type": "method",
      "name": "reset_stats",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 196,
      "line_end": 199,
      "description": "Reset performance statistics.",
      "content": "def reset_stats(self) -> None:\n        \"\"\"Reset performance statistics.\"\"\"\n        self.moves_made = 0\n        self.successful_moves = 0",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "AIPlayer"
      },
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AdvancedAI:202",
      "type": "class",
      "name": "AdvancedAI",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 202,
      "line_end": 259,
      "description": "Advanced AI with learning capabilities and multiple strategies.",
      "content": "class AdvancedAI(AIPlayer):\n    \"\"\"Advanced AI with learning capabilities and multiple strategies.\"\"\"\n    \n    def __init__(self):\n        super().__init__(AIStrategy.PATHFINDING)\n        self.strategy_performance = {\n            AIStrategy.GREEDY: {\"score\": 0, \"games\": 0},\n            AIStrategy.PATHFINDING: {\"score\": 0, \"games\": 0},\n            AIStrategy.HAMILTONIAN: {\"score\": 0, \"games\": 0}\n        }\n        self.current_strategy = AIStrategy.PATHFINDING\n        self.adaptation_threshold = 5  # Games before considering strategy change\n    \n    def get_next_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Get next move using adaptive strategy selection.\"\"\"\n        # Use current strategy\n        old_strategy = self.strategy\n        self.strategy = self.current_strategy\n        move = super().get_next_move(snake, food, grid_width, grid_height)\n        self.strategy = old_strategy\n        \n        return move\n    \n    def record_game_result(self, strategy: AIStrategy, score: int) -> None:\n        \"\"\"Record the result of a game for strategy evaluation.\"\"\"\n        if strategy in self.strategy_performance:\n            self.strategy_performance[strategy][\"score\"] += score\n            self.strategy_performance[strategy][\"games\"] += 1\n            \n            # Adapt strategy if enough games played\n            if self.strategy_performance[strategy][\"games\"] >= self.adaptation_threshold:\n                self._adapt_strategy()\n    \n    def _adapt_strategy(self) -> None:\n        \"\"\"Adapt strategy based on performance.\"\"\"\n        best_strategy = self.current_strategy\n        best_avg_score = 0\n        \n        for strategy, stats in self.strategy_performance.items():\n            if stats[\"games\"] > 0:\n                avg_score = stats[\"score\"] / stats[\"games\"]\n                if avg_score > best_avg_score:\n                    best_avg_score = avg_score\n                    best_strategy = strategy\n        \n        self.current_strategy = best_strategy\n    \n    def get_strategy_stats(self) -> dict:\n        \"\"\"Get statistics for all strategies.\"\"\"\n        stats = {}\n        for strategy, data in self.strategy_performance.items():\n            avg_score = data[\"score\"] / max(1, data[\"games\"])\n            stats[strategy.value] = {\n                \"games_played\": data[\"games\"],\n                \"total_score\": data[\"score\"],\n                \"average_score\": avg_score\n            }\n        return stats",
      "language": "python",
      "metadata": {
        "base_classes": [
          "AIPlayer"
        ],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:__init__:205",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 205,
      "line_end": 213,
      "description": "Python method: __init__",
      "content": "def __init__(self):\n        super().__init__(AIStrategy.PATHFINDING)\n        self.strategy_performance = {\n            AIStrategy.GREEDY: {\"score\": 0, \"games\": 0},\n            AIStrategy.PATHFINDING: {\"score\": 0, \"games\": 0},\n            AIStrategy.HAMILTONIAN: {\"score\": 0, \"games\": 0}\n        }\n        self.current_strategy = AIStrategy.PATHFINDING\n        self.adaptation_threshold = 5  # Games before considering strategy change",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "AdvancedAI"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:get_next_move:215",
      "type": "method",
      "name": "get_next_move",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 215,
      "line_end": 223,
      "description": "Get next move using adaptive strategy selection.",
      "content": "def get_next_move(self, snake: Snake, food: Food, grid_width: int, grid_height: int) -> Direction:\n        \"\"\"Get next move using adaptive strategy selection.\"\"\"\n        # Use current strategy\n        old_strategy = self.strategy\n        self.strategy = self.current_strategy\n        move = super().get_next_move(snake, food, grid_width, grid_height)\n        self.strategy = old_strategy\n        \n        return move",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "AdvancedAI"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:record_game_result:225",
      "type": "method",
      "name": "record_game_result",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 225,
      "line_end": 233,
      "description": "Record the result of a game for strategy evaluation.",
      "content": "def record_game_result(self, strategy: AIStrategy, score: int) -> None:\n        \"\"\"Record the result of a game for strategy evaluation.\"\"\"\n        if strategy in self.strategy_performance:\n            self.strategy_performance[strategy][\"score\"] += score\n            self.strategy_performance[strategy][\"games\"] += 1\n            \n            # Adapt strategy if enough games played\n            if self.strategy_performance[strategy][\"games\"] >= self.adaptation_threshold:\n                self._adapt_strategy()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "AdvancedAI"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:_adapt_strategy:235",
      "type": "method",
      "name": "_adapt_strategy",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 235,
      "line_end": 247,
      "description": "Adapt strategy based on performance.",
      "content": "def _adapt_strategy(self) -> None:\n        \"\"\"Adapt strategy based on performance.\"\"\"\n        best_strategy = self.current_strategy\n        best_avg_score = 0\n        \n        for strategy, stats in self.strategy_performance.items():\n            if stats[\"games\"] > 0:\n                avg_score = stats[\"score\"] / stats[\"games\"]\n                if avg_score > best_avg_score:\n                    best_avg_score = avg_score\n                    best_strategy = strategy\n        \n        self.current_strategy = best_strategy",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "AdvancedAI"
      },
      "embedding": null
    },
    {
      "id": "method:ai_player.py:get_strategy_stats:249",
      "type": "method",
      "name": "get_strategy_stats",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 249,
      "line_end": 259,
      "description": "Get statistics for all strategies.",
      "content": "def get_strategy_stats(self) -> dict:\n        \"\"\"Get statistics for all strategies.\"\"\"\n        stats = {}\n        for strategy, data in self.strategy_performance.items():\n            avg_score = data[\"score\"] / max(1, data[\"games\"])\n            stats[strategy.value] = {\n                \"games_played\": data[\"games\"],\n                \"total_score\": data[\"score\"],\n                \"average_score\": avg_score\n            }\n        return stats",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "AdvancedAI"
      },
      "embedding": null
    },
    {
      "id": "function:ai_player.py:create_ai_player:262",
      "type": "function",
      "name": "create_ai_player",
      "path": "/workspace/Coretx/examples/snake_game/ai_player.py",
      "line_start": 262,
      "line_end": 276,
      "description": "Factory function to create AI players of different difficulties.",
      "content": "def create_ai_player(difficulty: str = \"medium\") -> AIPlayer:\n    \"\"\"Factory function to create AI players of different difficulties.\"\"\"\n    difficulty_map = {\n        \"easy\": AIStrategy.RANDOM,\n        \"medium\": AIStrategy.GREEDY,\n        \"hard\": AIStrategy.PATHFINDING,\n        \"expert\": AIStrategy.HAMILTONIAN\n    }\n    \n    strategy = difficulty_map.get(difficulty.lower(), AIStrategy.GREEDY)\n    \n    if difficulty.lower() == \"adaptive\":\n        return AdvancedAI()\n    else:\n        return AIPlayer(strategy)",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "module:main.py:main:1",
      "type": "module",
      "name": "main",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 1,
      "line_end": 215,
      "description": "Main entry point for the Snake Game.\nProvides command-line interface and game mode selection.",
      "content": "\"\"\"\nMain entry point for the Snake Game.\nProvides command-line interface and game mode selection.\n\"\"\"\n\nimport argparse\nimport sys\nimport time\nfrom typing import Optional\nfrom game import SnakeGame, GameConfig\nfrom ai_player import create_ai_player, AIStrategy\nfrom utils import GameStats, ConfigManager\n\n\ndef run_human_game(config: Optional[GameConfig] = None) -> None:\n    \"\"\"Run the game in human player mode.\"\"\"\n    print(\"Starting Snake Game - Human Player Mode\")\n    print(\"Controls: Arrow keys or WASD to move, SPACE to pause, ESC to quit\")\n    \n    game = SnakeGame(config)\n    game.run()\n\n\ndef run_ai_game(difficulty: str = \"medium\", config: Optional[GameConfig] = None, \n                games_to_play: int = 1, show_stats: bool = True) -> None:\n    \"\"\"Run the game in AI player mode.\"\"\"\n    print(f\"Starting Snake Game - AI Player Mode (Difficulty: {difficulty})\")\n    \n    ai_player = create_ai_player(difficulty)\n    stats = GameStats()\n    \n    for game_num in range(games_to_play):\n        print(f\"\\nGame {game_num + 1}/{games_to_play}\")\n        \n        # Create game instance\n        game = SnakeGame(config)\n        game_start_time = time.time()\n        \n        # Override input handling for AI\n        while game.running and game.game_state.value != \"game_over\":\n            # Get AI move\n            if game.game_state.value == \"playing\":\n                ai_direction = ai_player.get_next_move(\n                    game.snake, game.food, game.grid_width, game.grid_height\n                )\n                game.snake.change_direction(ai_direction)\n            \n            # Update game\n            game.update_game_logic()\n            \n            # Optional: render game (comment out for faster execution)\n            if games_to_play == 1:  # Only render if playing single game\n                game.render_game()\n            \n            # Small delay to make it watchable\n            if games_to_play == 1:\n                time.sleep(0.1)\n        \n        # Record game statistics\n        game_time = time.time() - game_start_time\n        final_score = game.score_manager.score\n        food_eaten = game.score_manager.food_eaten\n        \n        stats.record_game(final_score, food_eaten, game_time)\n        \n        print(f\"Game {game_num + 1} completed - Score: {final_score}, Food: {food_eaten}, Time: {game_time:.1f}s\")\n        \n        # Clean up pygame for this game\n        import pygame\n        pygame.quit()\n    \n    # Show final statistics\n    if show_stats:\n        print(\"\\n\" + \"=\"*50)\n        print(\"AI PERFORMANCE STATISTICS\")\n        print(\"=\"*50)\n        \n        game_stats = stats.get_stats_dict()\n        print(f\"Games Played: {game_stats['games_played']}\")\n        print(f\"Total Score: {game_stats['total_score']}\")\n        print(f\"Highest Score: {game_stats['highest_score']}\")\n        print(f\"Average Score: {game_stats['average_score']:.1f}\")\n        print(f\"Total Food Eaten: {game_stats['total_food_eaten']}\")\n        print(f\"Average Game Length: {game_stats['average_game_length']:.1f}s\")\n        \n        ai_stats = ai_player.get_performance_stats()\n        print(f\"AI Success Rate: {ai_stats['success_rate']:.2%}\")\n        print(f\"Strategy Used: {ai_stats['strategy']}\")\n\n\ndef run_benchmark(config: Optional[GameConfig] = None) -> None:\n    \"\"\"Run benchmark comparing different AI strategies.\"\"\"\n    print(\"Running AI Strategy Benchmark...\")\n    \n    strategies = [\"easy\", \"medium\", \"hard\", \"expert\"]\n    games_per_strategy = 10\n    \n    results = {}\n    \n    for strategy in strategies:\n        print(f\"\\nTesting {strategy} strategy...\")\n        ai_player = create_ai_player(strategy)\n        stats = GameStats()\n        \n        for game_num in range(games_per_strategy):\n            # Create and run game\n            game = SnakeGame(config)\n            game_start_time = time.time()\n            \n            while game.running and game.game_state.value != \"game_over\":\n                if game.game_state.value == \"playing\":\n                    ai_direction = ai_player.get_next_move(\n                        game.snake, game.food, game.grid_width, game.grid_height\n                    )\n                    game.snake.change_direction(ai_direction)\n                \n                game.update_game_logic()\n            \n            # Record stats\n            game_time = time.time() - game_start_time\n            stats.record_game(game.score_manager.score, game.score_manager.food_eaten, game_time)\n            \n            import pygame\n            pygame.quit()\n        \n        # Store results\n        game_stats = stats.get_stats_dict()\n        results[strategy] = {\n            \"average_score\": game_stats['average_score'],\n            \"highest_score\": game_stats['highest_score'],\n            \"average_time\": game_stats['average_game_length']\n        }\n    \n    # Display benchmark results\n    print(\"\\n\" + \"=\"*60)\n    print(\"BENCHMARK RESULTS\")\n    print(\"=\"*60)\n    print(f\"{'Strategy':<12} {'Avg Score':<12} {'High Score':<12} {'Avg Time':<12}\")\n    print(\"-\" * 60)\n    \n    for strategy, stats in results.items():\n        print(f\"{strategy:<12} {stats['average_score']:<12.1f} {stats['highest_score']:<12} {stats['average_time']:<12.1f}\")\n\n\ndef create_config_from_args(args) -> GameConfig:\n    \"\"\"Create game configuration from command line arguments.\"\"\"\n    config = GameConfig()\n    \n    if args.width:\n        config.window_width = args.width\n    if args.height:\n        config.window_height = args.height\n    if args.grid_size:\n        config.grid_size = args.grid_size\n    if args.fps:\n        config.fps = args.fps\n    \n    return config\n\n\ndef main():\n    \"\"\"Main entry point with command line argument parsing.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Snake Game with AI\")\n    \n    # Game mode selection\n    parser.add_argument(\"--mode\", choices=[\"human\", \"ai\", \"benchmark\"], \n                       default=\"human\", help=\"Game mode to run\")\n    \n    # AI configuration\n    parser.add_argument(\"--difficulty\", choices=[\"easy\", \"medium\", \"hard\", \"expert\", \"adaptive\"],\n                       default=\"medium\", help=\"AI difficulty level\")\n    parser.add_argument(\"--games\", type=int, default=1, \n                       help=\"Number of games to play in AI mode\")\n    \n    # Game configuration\n    parser.add_argument(\"--width\", type=int, help=\"Window width\")\n    parser.add_argument(\"--height\", type=int, help=\"Window height\")\n    parser.add_argument(\"--grid-size\", type=int, help=\"Grid cell size\")\n    parser.add_argument(\"--fps\", type=int, help=\"Frames per second\")\n    \n    # Configuration file\n    parser.add_argument(\"--config\", help=\"Load configuration from file\")\n    parser.add_argument(\"--save-config\", help=\"Save current configuration to file\")\n    \n    args = parser.parse_args()\n    \n    # Load configuration\n    if args.config:\n        config = ConfigManager.load_config(args.config)\n    else:\n        config = create_config_from_args(args)\n    \n    # Save configuration if requested\n    if args.save_config:\n        ConfigManager.save_config(config, args.save_config)\n        print(f\"Configuration saved to {args.save_config}\")\n        return\n    \n    # Run appropriate game mode\n    try:\n        if args.mode == \"human\":\n            run_human_game(config)\n        elif args.mode == \"ai\":\n            run_ai_game(args.difficulty, config, args.games)\n        elif args.mode == \"benchmark\":\n            run_benchmark(config)\n    except KeyboardInterrupt:\n        print(\"\\nGame interrupted by user\")\n    except Exception as e:\n        print(f\"Error running game: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "metadata": {
        "is_package": false,
        "line_count": 215
      },
      "embedding": null
    },
    {
      "id": "import:main.py:import argparse:6",
      "type": "import",
      "name": "import argparse",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 6,
      "line_end": 6,
      "description": "",
      "content": "import argparse",
      "language": "python",
      "metadata": {
        "imported_names": [
          "argparse"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:import sys:7",
      "type": "import",
      "name": "import sys",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 7,
      "line_end": 7,
      "description": "",
      "content": "import sys",
      "language": "python",
      "metadata": {
        "imported_names": [
          "sys"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:import time:8",
      "type": "import",
      "name": "import time",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 8,
      "line_end": 8,
      "description": "",
      "content": "import time",
      "language": "python",
      "metadata": {
        "imported_names": [
          "time"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:import pygame:69",
      "type": "import",
      "name": "import pygame",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 69,
      "line_end": 69,
      "description": "",
      "content": "import pygame",
      "language": "python",
      "metadata": {
        "imported_names": [
          "pygame"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:import pygame:123",
      "type": "import",
      "name": "import pygame",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 123,
      "line_end": 123,
      "description": "",
      "content": "import pygame",
      "language": "python",
      "metadata": {
        "imported_names": [
          "pygame"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:from typing import Optional:9",
      "type": "import",
      "name": "from typing import Optional",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 9,
      "line_end": 9,
      "description": "",
      "content": "from typing import Optional",
      "language": "python",
      "metadata": {
        "imported_names": [
          "Optional"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:from game import SnakeGame, GameConfig:10",
      "type": "import",
      "name": "from game import SnakeGame, GameConfig",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 10,
      "line_end": 10,
      "description": "",
      "content": "from game import SnakeGame, GameConfig",
      "language": "python",
      "metadata": {
        "imported_names": [
          "SnakeGame",
          "GameConfig"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:from ai_player import create_ai_player, AIStrategy:11",
      "type": "import",
      "name": "from ai_player import create_ai_player, AIStrategy",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 11,
      "line_end": 11,
      "description": "",
      "content": "from ai_player import create_ai_player, AIStrategy",
      "language": "python",
      "metadata": {
        "imported_names": [
          "create_ai_player",
          "AIStrategy"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:main.py:from utils import GameStats, ConfigManager:12",
      "type": "import",
      "name": "from utils import GameStats, ConfigManager",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 12,
      "line_end": 12,
      "description": "",
      "content": "from utils import GameStats, ConfigManager",
      "language": "python",
      "metadata": {
        "imported_names": [
          "GameStats",
          "ConfigManager"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "function:main.py:run_human_game:15",
      "type": "function",
      "name": "run_human_game",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 15,
      "line_end": 21,
      "description": "Run the game in human player mode.",
      "content": "def run_human_game(config: Optional[GameConfig] = None) -> None:\n    \"\"\"Run the game in human player mode.\"\"\"\n    print(\"Starting Snake Game - Human Player Mode\")\n    print(\"Controls: Arrow keys or WASD to move, SPACE to pause, ESC to quit\")\n    \n    game = SnakeGame(config)\n    game.run()",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "function:main.py:run_ai_game:24",
      "type": "function",
      "name": "run_ai_game",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 24,
      "line_end": 88,
      "description": "Run the game in AI player mode.",
      "content": "def run_ai_game(difficulty: str = \"medium\", config: Optional[GameConfig] = None, \n                games_to_play: int = 1, show_stats: bool = True) -> None:\n    \"\"\"Run the game in AI player mode.\"\"\"\n    print(f\"Starting Snake Game - AI Player Mode (Difficulty: {difficulty})\")\n    \n    ai_player = create_ai_player(difficulty)\n    stats = GameStats()\n    \n    for game_num in range(games_to_play):\n        print(f\"\\nGame {game_num + 1}/{games_to_play}\")\n        \n        # Create game instance\n        game = SnakeGame(config)\n        game_start_time = time.time()\n        \n        # Override input handling for AI\n        while game.running and game.game_state.value != \"game_over\":\n            # Get AI move\n            if game.game_state.value == \"playing\":\n                ai_direction = ai_player.get_next_move(\n                    game.snake, game.food, game.grid_width, game.grid_height\n                )\n                game.snake.change_direction(ai_direction)\n            \n            # Update game\n            game.update_game_logic()\n            \n            # Optional: render game (comment out for faster execution)\n            if games_to_play == 1:  # Only render if playing single game\n                game.render_game()\n            \n            # Small delay to make it watchable\n            if games_to_play == 1:\n                time.sleep(0.1)\n        \n        # Record game statistics\n        game_time = time.time() - game_start_time\n        final_score = game.score_manager.score\n        food_eaten = game.score_manager.food_eaten\n        \n        stats.record_game(final_score, food_eaten, game_time)\n        \n        print(f\"Game {game_num + 1} completed - Score: {final_score}, Food: {food_eaten}, Time: {game_time:.1f}s\")\n        \n        # Clean up pygame for this game\n        import pygame\n        pygame.quit()\n    \n    # Show final statistics\n    if show_stats:\n        print(\"\\n\" + \"=\"*50)\n        print(\"AI PERFORMANCE STATISTICS\")\n        print(\"=\"*50)\n        \n        game_stats = stats.get_stats_dict()\n        print(f\"Games Played: {game_stats['games_played']}\")\n        print(f\"Total Score: {game_stats['total_score']}\")\n        print(f\"Highest Score: {game_stats['highest_score']}\")\n        print(f\"Average Score: {game_stats['average_score']:.1f}\")\n        print(f\"Total Food Eaten: {game_stats['total_food_eaten']}\")\n        print(f\"Average Game Length: {game_stats['average_game_length']:.1f}s\")\n        \n        ai_stats = ai_player.get_performance_stats()\n        print(f\"AI Success Rate: {ai_stats['success_rate']:.2%}\")\n        print(f\"Strategy Used: {ai_stats['strategy']}\")",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "function:main.py:run_benchmark:91",
      "type": "function",
      "name": "run_benchmark",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 91,
      "line_end": 142,
      "description": "Run benchmark comparing different AI strategies.",
      "content": "def run_benchmark(config: Optional[GameConfig] = None) -> None:\n    \"\"\"Run benchmark comparing different AI strategies.\"\"\"\n    print(\"Running AI Strategy Benchmark...\")\n    \n    strategies = [\"easy\", \"medium\", \"hard\", \"expert\"]\n    games_per_strategy = 10\n    \n    results = {}\n    \n    for strategy in strategies:\n        print(f\"\\nTesting {strategy} strategy...\")\n        ai_player = create_ai_player(strategy)\n        stats = GameStats()\n        \n        for game_num in range(games_per_strategy):\n            # Create and run game\n            game = SnakeGame(config)\n            game_start_time = time.time()\n            \n            while game.running and game.game_state.value != \"game_over\":\n                if game.game_state.value == \"playing\":\n                    ai_direction = ai_player.get_next_move(\n                        game.snake, game.food, game.grid_width, game.grid_height\n                    )\n                    game.snake.change_direction(ai_direction)\n                \n                game.update_game_logic()\n            \n            # Record stats\n            game_time = time.time() - game_start_time\n            stats.record_game(game.score_manager.score, game.score_manager.food_eaten, game_time)\n            \n            import pygame\n            pygame.quit()\n        \n        # Store results\n        game_stats = stats.get_stats_dict()\n        results[strategy] = {\n            \"average_score\": game_stats['average_score'],\n            \"highest_score\": game_stats['highest_score'],\n            \"average_time\": game_stats['average_game_length']\n        }\n    \n    # Display benchmark results\n    print(\"\\n\" + \"=\"*60)\n    print(\"BENCHMARK RESULTS\")\n    print(\"=\"*60)\n    print(f\"{'Strategy':<12} {'Avg Score':<12} {'High Score':<12} {'Avg Time':<12}\")\n    print(\"-\" * 60)\n    \n    for strategy, stats in results.items():\n        print(f\"{strategy:<12} {stats['average_score']:<12.1f} {stats['highest_score']:<12} {stats['average_time']:<12.1f}\")",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "function:main.py:create_config_from_args:145",
      "type": "function",
      "name": "create_config_from_args",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 145,
      "line_end": 158,
      "description": "Create game configuration from command line arguments.",
      "content": "def create_config_from_args(args) -> GameConfig:\n    \"\"\"Create game configuration from command line arguments.\"\"\"\n    config = GameConfig()\n    \n    if args.width:\n        config.window_width = args.width\n    if args.height:\n        config.window_height = args.height\n    if args.grid_size:\n        config.grid_size = args.grid_size\n    if args.fps:\n        config.fps = args.fps\n    \n    return config",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "args",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "function:main.py:main:161",
      "type": "function",
      "name": "main",
      "path": "/workspace/Coretx/examples/snake_game/main.py",
      "line_start": 161,
      "line_end": 211,
      "description": "Main entry point with command line argument parsing.",
      "content": "def main():\n    \"\"\"Main entry point with command line argument parsing.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Snake Game with AI\")\n    \n    # Game mode selection\n    parser.add_argument(\"--mode\", choices=[\"human\", \"ai\", \"benchmark\"], \n                       default=\"human\", help=\"Game mode to run\")\n    \n    # AI configuration\n    parser.add_argument(\"--difficulty\", choices=[\"easy\", \"medium\", \"hard\", \"expert\", \"adaptive\"],\n                       default=\"medium\", help=\"AI difficulty level\")\n    parser.add_argument(\"--games\", type=int, default=1, \n                       help=\"Number of games to play in AI mode\")\n    \n    # Game configuration\n    parser.add_argument(\"--width\", type=int, help=\"Window width\")\n    parser.add_argument(\"--height\", type=int, help=\"Window height\")\n    parser.add_argument(\"--grid-size\", type=int, help=\"Grid cell size\")\n    parser.add_argument(\"--fps\", type=int, help=\"Frames per second\")\n    \n    # Configuration file\n    parser.add_argument(\"--config\", help=\"Load configuration from file\")\n    parser.add_argument(\"--save-config\", help=\"Save current configuration to file\")\n    \n    args = parser.parse_args()\n    \n    # Load configuration\n    if args.config:\n        config = ConfigManager.load_config(args.config)\n    else:\n        config = create_config_from_args(args)\n    \n    # Save configuration if requested\n    if args.save_config:\n        ConfigManager.save_config(config, args.save_config)\n        print(f\"Configuration saved to {args.save_config}\")\n        return\n    \n    # Run appropriate game mode\n    try:\n        if args.mode == \"human\":\n            run_human_game(config)\n        elif args.mode == \"ai\":\n            run_ai_game(args.difficulty, config, args.games)\n        elif args.mode == \"benchmark\":\n            run_benchmark(config)\n    except KeyboardInterrupt:\n        print(\"\\nGame interrupted by user\")\n    except Exception as e:\n        print(f\"Error running game: {e}\")\n        sys.exit(1)",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "module:game.py:game:1",
      "type": "module",
      "name": "game",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 1,
      "line_end": 388,
      "description": "Snake Game Implementation\nA classic snake game using pygame with object-oriented design.",
      "content": "\"\"\"\nSnake Game Implementation\nA classic snake game using pygame with object-oriented design.\n\"\"\"\n\nimport pygame\nimport random\nimport sys\nfrom enum import Enum\nfrom typing import List, Tuple, Optional\nfrom dataclasses import dataclass\n\n\nclass Direction(Enum):\n    \"\"\"Enumeration for movement directions.\"\"\"\n    UP = (0, -1)\n    DOWN = (0, 1)\n    LEFT = (-1, 0)\n    RIGHT = (1, 0)\n\n\nclass GameState(Enum):\n    \"\"\"Enumeration for game states.\"\"\"\n    PLAYING = \"playing\"\n    GAME_OVER = \"game_over\"\n    PAUSED = \"paused\"\n\n\n@dataclass\nclass Position:\n    \"\"\"Represents a position on the game grid.\"\"\"\n    x: int\n    y: int\n    \n    def __add__(self, other: 'Position') -> 'Position':\n        return Position(self.x + other.x, self.y + other.y)\n    \n    def __eq__(self, other: 'Position') -> bool:\n        return self.x == other.x and self.y == other.y\n\n\n@dataclass\nclass GameConfig:\n    \"\"\"Configuration settings for the game.\"\"\"\n    window_width: int = 800\n    window_height: int = 600\n    grid_size: int = 20\n    fps: int = 10\n    snake_color: Tuple[int, int, int] = (0, 255, 0)\n    food_color: Tuple[int, int, int] = (255, 0, 0)\n    background_color: Tuple[int, int, int] = (0, 0, 0)\n    border_color: Tuple[int, int, int] = (255, 255, 255)\n\n\nclass Food:\n    \"\"\"Represents food items in the game.\"\"\"\n    \n    def __init__(self, grid_width: int, grid_height: int):\n        self.grid_width = grid_width\n        self.grid_height = grid_height\n        self.position = self._generate_position()\n    \n    def _generate_position(self) -> Position:\n        \"\"\"Generate a random position for the food.\"\"\"\n        x = random.randint(0, self.grid_width - 1)\n        y = random.randint(0, self.grid_height - 1)\n        return Position(x, y)\n    \n    def respawn(self, snake_positions: List[Position]) -> None:\n        \"\"\"Respawn food at a new location not occupied by snake.\"\"\"\n        while True:\n            self.position = self._generate_position()\n            if self.position not in snake_positions:\n                break\n    \n    def draw(self, screen: pygame.Surface, config: GameConfig) -> None:\n        \"\"\"Draw the food on the screen.\"\"\"\n        rect = pygame.Rect(\n            self.position.x * config.grid_size,\n            self.position.y * config.grid_size,\n            config.grid_size,\n            config.grid_size\n        )\n        pygame.draw.rect(screen, config.food_color, rect)\n\n\nclass Snake:\n    \"\"\"Represents the snake player.\"\"\"\n    \n    def __init__(self, start_position: Position, initial_length: int = 3):\n        self.body = [Position(start_position.x - i, start_position.y) \n                    for i in range(initial_length)]\n        self.direction = Direction.RIGHT\n        self.grow_pending = 0\n    \n    def move(self) -> None:\n        \"\"\"Move the snake in the current direction.\"\"\"\n        # Calculate new head position\n        direction_offset = Position(*self.direction.value)\n        new_head = self.body[0] + direction_offset\n        \n        # Add new head\n        self.body.insert(0, new_head)\n        \n        # Remove tail unless growing\n        if self.grow_pending > 0:\n            self.grow_pending -= 1\n        else:\n            self.body.pop()\n    \n    def change_direction(self, new_direction: Direction) -> None:\n        \"\"\"Change snake direction if valid.\"\"\"\n        # Prevent reversing into itself\n        opposite_directions = {\n            Direction.UP: Direction.DOWN,\n            Direction.DOWN: Direction.UP,\n            Direction.LEFT: Direction.RIGHT,\n            Direction.RIGHT: Direction.LEFT\n        }\n        \n        if new_direction != opposite_directions.get(self.direction):\n            self.direction = new_direction\n    \n    def grow(self, segments: int = 1) -> None:\n        \"\"\"Schedule the snake to grow.\"\"\"\n        self.grow_pending += segments\n    \n    def check_collision_with_self(self) -> bool:\n        \"\"\"Check if snake has collided with itself.\"\"\"\n        head = self.body[0]\n        return head in self.body[1:]\n    \n    def check_collision_with_walls(self, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Check if snake has collided with walls.\"\"\"\n        head = self.body[0]\n        return (head.x < 0 or head.x >= grid_width or \n                head.y < 0 or head.y >= grid_height)\n    \n    def get_head_position(self) -> Position:\n        \"\"\"Get the position of the snake's head.\"\"\"\n        return self.body[0]\n    \n    def get_body_positions(self) -> List[Position]:\n        \"\"\"Get all body segment positions.\"\"\"\n        return self.body.copy()\n    \n    def draw(self, screen: pygame.Surface, config: GameConfig) -> None:\n        \"\"\"Draw the snake on the screen.\"\"\"\n        for segment in self.body:\n            rect = pygame.Rect(\n                segment.x * config.grid_size,\n                segment.y * config.grid_size,\n                config.grid_size,\n                config.grid_size\n            )\n            pygame.draw.rect(screen, config.snake_color, rect)\n            pygame.draw.rect(screen, config.border_color, rect, 1)\n\n\nclass ScoreManager:\n    \"\"\"Manages game scoring and statistics.\"\"\"\n    \n    def __init__(self):\n        self.score = 0\n        self.high_score = 0\n        self.food_eaten = 0\n    \n    def add_points(self, points: int) -> None:\n        \"\"\"Add points to the current score.\"\"\"\n        self.score += points\n        if self.score > self.high_score:\n            self.high_score = self.score\n    \n    def food_consumed(self) -> None:\n        \"\"\"Record that food was consumed.\"\"\"\n        self.food_eaten += 1\n        self.add_points(10)\n    \n    def reset_score(self) -> None:\n        \"\"\"Reset the current game score.\"\"\"\n        self.score = 0\n        self.food_eaten = 0\n    \n    def get_score_text(self) -> str:\n        \"\"\"Get formatted score text.\"\"\"\n        return f\"Score: {self.score} | High Score: {self.high_score}\"\n\n\nclass GameRenderer:\n    \"\"\"Handles all game rendering operations.\"\"\"\n    \n    def __init__(self, config: GameConfig):\n        self.config = config\n        pygame.init()\n        self.screen = pygame.display.set_mode((config.window_width, config.window_height))\n        pygame.display.set_caption(\"Snake Game\")\n        self.font = pygame.font.Font(None, 36)\n        self.clock = pygame.time.Clock()\n    \n    def clear_screen(self) -> None:\n        \"\"\"Clear the screen with background color.\"\"\"\n        self.screen.fill(self.config.background_color)\n    \n    def draw_text(self, text: str, position: Tuple[int, int], color: Tuple[int, int, int] = (255, 255, 255)) -> None:\n        \"\"\"Draw text on the screen.\"\"\"\n        text_surface = self.font.render(text, True, color)\n        self.screen.blit(text_surface, position)\n    \n    def draw_game_over(self, score_manager: ScoreManager) -> None:\n        \"\"\"Draw game over screen.\"\"\"\n        self.clear_screen()\n        \n        game_over_text = \"GAME OVER\"\n        score_text = score_manager.get_score_text()\n        restart_text = \"Press SPACE to restart or ESC to quit\"\n        \n        # Center the text\n        game_over_rect = self.font.get_rect(game_over_text)\n        score_rect = self.font.get_rect(score_text)\n        restart_rect = self.font.get_rect(restart_text)\n        \n        center_x = self.config.window_width // 2\n        center_y = self.config.window_height // 2\n        \n        self.draw_text(game_over_text, (center_x - game_over_rect.width // 2, center_y - 60), (255, 0, 0))\n        self.draw_text(score_text, (center_x - score_rect.width // 2, center_y))\n        self.draw_text(restart_text, (center_x - restart_rect.width // 2, center_y + 60))\n    \n    def update_display(self) -> None:\n        \"\"\"Update the display and maintain FPS.\"\"\"\n        pygame.display.flip()\n        self.clock.tick(self.config.fps)\n\n\nclass InputHandler:\n    \"\"\"Handles user input and events.\"\"\"\n    \n    def __init__(self):\n        self.key_direction_map = {\n            pygame.K_UP: Direction.UP,\n            pygame.K_DOWN: Direction.DOWN,\n            pygame.K_LEFT: Direction.LEFT,\n            pygame.K_RIGHT: Direction.RIGHT,\n            pygame.K_w: Direction.UP,\n            pygame.K_s: Direction.DOWN,\n            pygame.K_a: Direction.LEFT,\n            pygame.K_d: Direction.RIGHT\n        }\n    \n    def handle_events(self, snake: Snake, game_state: GameState) -> Tuple[GameState, bool]:\n        \"\"\"Handle pygame events and return new game state and quit flag.\"\"\"\n        quit_game = False\n        \n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                quit_game = True\n            \n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_ESCAPE:\n                    quit_game = True\n                \n                elif event.key == pygame.K_SPACE:\n                    if game_state == GameState.GAME_OVER:\n                        game_state = GameState.PLAYING\n                    elif game_state == GameState.PLAYING:\n                        game_state = GameState.PAUSED\n                    elif game_state == GameState.PAUSED:\n                        game_state = GameState.PLAYING\n                \n                elif event.key in self.key_direction_map and game_state == GameState.PLAYING:\n                    new_direction = self.key_direction_map[event.key]\n                    snake.change_direction(new_direction)\n        \n        return game_state, quit_game\n\n\nclass SnakeGame:\n    \"\"\"Main game class that orchestrates all components.\"\"\"\n    \n    def __init__(self, config: Optional[GameConfig] = None):\n        self.config = config or GameConfig()\n        self.grid_width = self.config.window_width // self.config.grid_size\n        self.grid_height = self.config.window_height // self.config.grid_size\n        \n        # Initialize game components\n        self.renderer = GameRenderer(self.config)\n        self.input_handler = InputHandler()\n        self.score_manager = ScoreManager()\n        \n        # Initialize game objects\n        self.reset_game()\n        \n        self.game_state = GameState.PLAYING\n        self.running = True\n    \n    def reset_game(self) -> None:\n        \"\"\"Reset the game to initial state.\"\"\"\n        start_pos = Position(self.grid_width // 2, self.grid_height // 2)\n        self.snake = Snake(start_pos)\n        self.food = Food(self.grid_width, self.grid_height)\n        self.food.respawn(self.snake.get_body_positions())\n        self.score_manager.reset_score()\n    \n    def update_game_logic(self) -> None:\n        \"\"\"Update game logic for one frame.\"\"\"\n        if self.game_state != GameState.PLAYING:\n            return\n        \n        # Move snake\n        self.snake.move()\n        \n        # Check collisions\n        if (self.snake.check_collision_with_walls(self.grid_width, self.grid_height) or\n            self.snake.check_collision_with_self()):\n            self.game_state = GameState.GAME_OVER\n            return\n        \n        # Check food consumption\n        if self.snake.get_head_position() == self.food.position:\n            self.snake.grow()\n            self.score_manager.food_consumed()\n            self.food.respawn(self.snake.get_body_positions())\n    \n    def render_game(self) -> None:\n        \"\"\"Render the current game state.\"\"\"\n        if self.game_state == GameState.GAME_OVER:\n            self.renderer.draw_game_over(self.score_manager)\n        else:\n            self.renderer.clear_screen()\n            \n            # Draw game objects\n            self.food.draw(self.renderer.screen, self.config)\n            self.snake.draw(self.renderer.screen, self.config)\n            \n            # Draw UI\n            score_text = self.score_manager.get_score_text()\n            self.renderer.draw_text(score_text, (10, 10))\n            \n            if self.game_state == GameState.PAUSED:\n                pause_text = \"PAUSED - Press SPACE to continue\"\n                text_rect = self.renderer.font.get_rect(pause_text)\n                center_x = self.config.window_width // 2 - text_rect.width // 2\n                self.renderer.draw_text(pause_text, (center_x, 50), (255, 255, 0))\n        \n        self.renderer.update_display()\n    \n    def handle_input(self) -> None:\n        \"\"\"Handle user input.\"\"\"\n        new_state, quit_flag = self.input_handler.handle_events(self.snake, self.game_state)\n        \n        if quit_flag:\n            self.running = False\n        \n        if new_state == GameState.PLAYING and self.game_state == GameState.GAME_OVER:\n            self.reset_game()\n        \n        self.game_state = new_state\n    \n    def run(self) -> None:\n        \"\"\"Main game loop.\"\"\"\n        while self.running:\n            self.handle_input()\n            self.update_game_logic()\n            self.render_game()\n        \n        pygame.quit()\n        sys.exit()\n\n\ndef main():\n    \"\"\"Entry point for the snake game.\"\"\"\n    # Create custom configuration if needed\n    config = GameConfig(\n        window_width=800,\n        window_height=600,\n        grid_size=20,\n        fps=12,\n        snake_color=(0, 255, 0),\n        food_color=(255, 0, 0)\n    )\n    \n    # Create and run the game\n    game = SnakeGame(config)\n    game.run()\n\n\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "metadata": {
        "is_package": false,
        "line_count": 388
      },
      "embedding": null
    },
    {
      "id": "import:game.py:import pygame:6",
      "type": "import",
      "name": "import pygame",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 6,
      "line_end": 6,
      "description": "",
      "content": "import pygame",
      "language": "python",
      "metadata": {
        "imported_names": [
          "pygame"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:game.py:import random:7",
      "type": "import",
      "name": "import random",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 7,
      "line_end": 7,
      "description": "",
      "content": "import random",
      "language": "python",
      "metadata": {
        "imported_names": [
          "random"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:game.py:import sys:8",
      "type": "import",
      "name": "import sys",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 8,
      "line_end": 8,
      "description": "",
      "content": "import sys",
      "language": "python",
      "metadata": {
        "imported_names": [
          "sys"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:game.py:from enum import Enum:9",
      "type": "import",
      "name": "from enum import Enum",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 9,
      "line_end": 9,
      "description": "",
      "content": "from enum import Enum",
      "language": "python",
      "metadata": {
        "imported_names": [
          "Enum"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:game.py:from typing import List, Tuple, Optional:10",
      "type": "import",
      "name": "from typing import List, Tuple, Optional",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 10,
      "line_end": 10,
      "description": "",
      "content": "from typing import List, Tuple, Optional",
      "language": "python",
      "metadata": {
        "imported_names": [
          "List",
          "Tuple",
          "Optional"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:game.py:from dataclasses import dataclass:11",
      "type": "import",
      "name": "from dataclasses import dataclass",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 11,
      "line_end": 11,
      "description": "",
      "content": "from dataclasses import dataclass",
      "language": "python",
      "metadata": {
        "imported_names": [
          "dataclass"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "class:game.py:Direction:14",
      "type": "class",
      "name": "Direction",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 14,
      "line_end": 19,
      "description": "Enumeration for movement directions.",
      "content": "class Direction(Enum):\n    \"\"\"Enumeration for movement directions.\"\"\"\n    UP = (0, -1)\n    DOWN = (0, 1)\n    LEFT = (-1, 0)\n    RIGHT = (1, 0)",
      "language": "python",
      "metadata": {
        "base_classes": [
          "Enum"
        ],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "class:game.py:GameState:22",
      "type": "class",
      "name": "GameState",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 22,
      "line_end": 26,
      "description": "Enumeration for game states.",
      "content": "class GameState(Enum):\n    \"\"\"Enumeration for game states.\"\"\"\n    PLAYING = \"playing\"\n    GAME_OVER = \"game_over\"\n    PAUSED = \"paused\"",
      "language": "python",
      "metadata": {
        "base_classes": [
          "Enum"
        ],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "class:game.py:Position:30",
      "type": "class",
      "name": "Position",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 30,
      "line_end": 39,
      "description": "Represents a position on the game grid.",
      "content": "class Position:\n    \"\"\"Represents a position on the game grid.\"\"\"\n    x: int\n    y: int\n    \n    def __add__(self, other: 'Position') -> 'Position':\n        return Position(self.x + other.x, self.y + other.y)\n    \n    def __eq__(self, other: 'Position') -> bool:\n        return self.x == other.x and self.y == other.y",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [
          "@dataclass"
        ],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__add__:35",
      "type": "method",
      "name": "__add__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 35,
      "line_end": 36,
      "description": "Python method: __add__",
      "content": "def __add__(self, other: 'Position') -> 'Position':\n        return Position(self.x + other.x, self.y + other.y)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "Position"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__eq__:38",
      "type": "method",
      "name": "__eq__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 38,
      "line_end": 39,
      "description": "Python method: __eq__",
      "content": "def __eq__(self, other: 'Position') -> bool:\n        return self.x == other.x and self.y == other.y",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "Position"
      },
      "embedding": null
    },
    {
      "id": "class:game.py:GameConfig:43",
      "type": "class",
      "name": "GameConfig",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 43,
      "line_end": 52,
      "description": "Configuration settings for the game.",
      "content": "class GameConfig:\n    \"\"\"Configuration settings for the game.\"\"\"\n    window_width: int = 800\n    window_height: int = 600\n    grid_size: int = 20\n    fps: int = 10\n    snake_color: Tuple[int, int, int] = (0, 255, 0)\n    food_color: Tuple[int, int, int] = (255, 0, 0)\n    background_color: Tuple[int, int, int] = (0, 0, 0)\n    border_color: Tuple[int, int, int] = (255, 255, 255)",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [
          "@dataclass"
        ],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "class:game.py:Food:55",
      "type": "class",
      "name": "Food",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 55,
      "line_end": 84,
      "description": "Represents food items in the game.",
      "content": "class Food:\n    \"\"\"Represents food items in the game.\"\"\"\n    \n    def __init__(self, grid_width: int, grid_height: int):\n        self.grid_width = grid_width\n        self.grid_height = grid_height\n        self.position = self._generate_position()\n    \n    def _generate_position(self) -> Position:\n        \"\"\"Generate a random position for the food.\"\"\"\n        x = random.randint(0, self.grid_width - 1)\n        y = random.randint(0, self.grid_height - 1)\n        return Position(x, y)\n    \n    def respawn(self, snake_positions: List[Position]) -> None:\n        \"\"\"Respawn food at a new location not occupied by snake.\"\"\"\n        while True:\n            self.position = self._generate_position()\n            if self.position not in snake_positions:\n                break\n    \n    def draw(self, screen: pygame.Surface, config: GameConfig) -> None:\n        \"\"\"Draw the food on the screen.\"\"\"\n        rect = pygame.Rect(\n            self.position.x * config.grid_size,\n            self.position.y * config.grid_size,\n            config.grid_size,\n            config.grid_size\n        )\n        pygame.draw.rect(screen, config.food_color, rect)",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__init__:58",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 58,
      "line_end": 61,
      "description": "Python method: __init__",
      "content": "def __init__(self, grid_width: int, grid_height: int):\n        self.grid_width = grid_width\n        self.grid_height = grid_height\n        self.position = self._generate_position()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "Food"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:_generate_position:63",
      "type": "method",
      "name": "_generate_position",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 63,
      "line_end": 67,
      "description": "Generate a random position for the food.",
      "content": "def _generate_position(self) -> Position:\n        \"\"\"Generate a random position for the food.\"\"\"\n        x = random.randint(0, self.grid_width - 1)\n        y = random.randint(0, self.grid_height - 1)\n        return Position(x, y)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": true,
        "is_property": false,
        "parent_class": "Food"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:respawn:69",
      "type": "method",
      "name": "respawn",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 69,
      "line_end": 74,
      "description": "Respawn food at a new location not occupied by snake.",
      "content": "def respawn(self, snake_positions: List[Position]) -> None:\n        \"\"\"Respawn food at a new location not occupied by snake.\"\"\"\n        while True:\n            self.position = self._generate_position()\n            if self.position not in snake_positions:\n                break",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Food"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:draw:76",
      "type": "method",
      "name": "draw",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 76,
      "line_end": 84,
      "description": "Draw the food on the screen.",
      "content": "def draw(self, screen: pygame.Surface, config: GameConfig) -> None:\n        \"\"\"Draw the food on the screen.\"\"\"\n        rect = pygame.Rect(\n            self.position.x * config.grid_size,\n            self.position.y * config.grid_size,\n            config.grid_size,\n            config.grid_size\n        )\n        pygame.draw.rect(screen, config.food_color, rect)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Food"
      },
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87",
      "type": "class",
      "name": "Snake",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 87,
      "line_end": 157,
      "description": "Represents the snake player.",
      "content": "class Snake:\n    \"\"\"Represents the snake player.\"\"\"\n    \n    def __init__(self, start_position: Position, initial_length: int = 3):\n        self.body = [Position(start_position.x - i, start_position.y) \n                    for i in range(initial_length)]\n        self.direction = Direction.RIGHT\n        self.grow_pending = 0\n    \n    def move(self) -> None:\n        \"\"\"Move the snake in the current direction.\"\"\"\n        # Calculate new head position\n        direction_offset = Position(*self.direction.value)\n        new_head = self.body[0] + direction_offset\n        \n        # Add new head\n        self.body.insert(0, new_head)\n        \n        # Remove tail unless growing\n        if self.grow_pending > 0:\n            self.grow_pending -= 1\n        else:\n            self.body.pop()\n    \n    def change_direction(self, new_direction: Direction) -> None:\n        \"\"\"Change snake direction if valid.\"\"\"\n        # Prevent reversing into itself\n        opposite_directions = {\n            Direction.UP: Direction.DOWN,\n            Direction.DOWN: Direction.UP,\n            Direction.LEFT: Direction.RIGHT,\n            Direction.RIGHT: Direction.LEFT\n        }\n        \n        if new_direction != opposite_directions.get(self.direction):\n            self.direction = new_direction\n    \n    def grow(self, segments: int = 1) -> None:\n        \"\"\"Schedule the snake to grow.\"\"\"\n        self.grow_pending += segments\n    \n    def check_collision_with_self(self) -> bool:\n        \"\"\"Check if snake has collided with itself.\"\"\"\n        head = self.body[0]\n        return head in self.body[1:]\n    \n    def check_collision_with_walls(self, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Check if snake has collided with walls.\"\"\"\n        head = self.body[0]\n        return (head.x < 0 or head.x >= grid_width or \n                head.y < 0 or head.y >= grid_height)\n    \n    def get_head_position(self) -> Position:\n        \"\"\"Get the position of the snake's head.\"\"\"\n        return self.body[0]\n    \n    def get_body_positions(self) -> List[Position]:\n        \"\"\"Get all body segment positions.\"\"\"\n        return self.body.copy()\n    \n    def draw(self, screen: pygame.Surface, config: GameConfig) -> None:\n        \"\"\"Draw the snake on the screen.\"\"\"\n        for segment in self.body:\n            rect = pygame.Rect(\n                segment.x * config.grid_size,\n                segment.y * config.grid_size,\n                config.grid_size,\n                config.grid_size\n            )\n            pygame.draw.rect(screen, config.snake_color, rect)\n            pygame.draw.rect(screen, config.border_color, rect, 1)",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__init__:90",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 90,
      "line_end": 94,
      "description": "Python method: __init__",
      "content": "def __init__(self, start_position: Position, initial_length: int = 3):\n        self.body = [Position(start_position.x - i, start_position.y) \n                    for i in range(initial_length)]\n        self.direction = Direction.RIGHT\n        self.grow_pending = 0",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:move:96",
      "type": "method",
      "name": "move",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 96,
      "line_end": 109,
      "description": "Move the snake in the current direction.",
      "content": "def move(self) -> None:\n        \"\"\"Move the snake in the current direction.\"\"\"\n        # Calculate new head position\n        direction_offset = Position(*self.direction.value)\n        new_head = self.body[0] + direction_offset\n        \n        # Add new head\n        self.body.insert(0, new_head)\n        \n        # Remove tail unless growing\n        if self.grow_pending > 0:\n            self.grow_pending -= 1\n        else:\n            self.body.pop()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:change_direction:111",
      "type": "method",
      "name": "change_direction",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 111,
      "line_end": 122,
      "description": "Change snake direction if valid.",
      "content": "def change_direction(self, new_direction: Direction) -> None:\n        \"\"\"Change snake direction if valid.\"\"\"\n        # Prevent reversing into itself\n        opposite_directions = {\n            Direction.UP: Direction.DOWN,\n            Direction.DOWN: Direction.UP,\n            Direction.LEFT: Direction.RIGHT,\n            Direction.RIGHT: Direction.LEFT\n        }\n        \n        if new_direction != opposite_directions.get(self.direction):\n            self.direction = new_direction",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:grow:124",
      "type": "method",
      "name": "grow",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 124,
      "line_end": 126,
      "description": "Schedule the snake to grow.",
      "content": "def grow(self, segments: int = 1) -> None:\n        \"\"\"Schedule the snake to grow.\"\"\"\n        self.grow_pending += segments",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:check_collision_with_self:128",
      "type": "method",
      "name": "check_collision_with_self",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 128,
      "line_end": 131,
      "description": "Check if snake has collided with itself.",
      "content": "def check_collision_with_self(self) -> bool:\n        \"\"\"Check if snake has collided with itself.\"\"\"\n        head = self.body[0]\n        return head in self.body[1:]",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:check_collision_with_walls:133",
      "type": "method",
      "name": "check_collision_with_walls",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 133,
      "line_end": 137,
      "description": "Check if snake has collided with walls.",
      "content": "def check_collision_with_walls(self, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Check if snake has collided with walls.\"\"\"\n        head = self.body[0]\n        return (head.x < 0 or head.x >= grid_width or \n                head.y < 0 or head.y >= grid_height)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:get_head_position:139",
      "type": "method",
      "name": "get_head_position",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 139,
      "line_end": 141,
      "description": "Get the position of the snake's head.",
      "content": "def get_head_position(self) -> Position:\n        \"\"\"Get the position of the snake's head.\"\"\"\n        return self.body[0]",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:get_body_positions:143",
      "type": "method",
      "name": "get_body_positions",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 143,
      "line_end": 145,
      "description": "Get all body segment positions.",
      "content": "def get_body_positions(self) -> List[Position]:\n        \"\"\"Get all body segment positions.\"\"\"\n        return self.body.copy()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:draw:147",
      "type": "method",
      "name": "draw",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 147,
      "line_end": 157,
      "description": "Draw the snake on the screen.",
      "content": "def draw(self, screen: pygame.Surface, config: GameConfig) -> None:\n        \"\"\"Draw the snake on the screen.\"\"\"\n        for segment in self.body:\n            rect = pygame.Rect(\n                segment.x * config.grid_size,\n                segment.y * config.grid_size,\n                config.grid_size,\n                config.grid_size\n            )\n            pygame.draw.rect(screen, config.snake_color, rect)\n            pygame.draw.rect(screen, config.border_color, rect, 1)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "Snake"
      },
      "embedding": null
    },
    {
      "id": "class:game.py:ScoreManager:160",
      "type": "class",
      "name": "ScoreManager",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 160,
      "line_end": 186,
      "description": "Manages game scoring and statistics.",
      "content": "class ScoreManager:\n    \"\"\"Manages game scoring and statistics.\"\"\"\n    \n    def __init__(self):\n        self.score = 0\n        self.high_score = 0\n        self.food_eaten = 0\n    \n    def add_points(self, points: int) -> None:\n        \"\"\"Add points to the current score.\"\"\"\n        self.score += points\n        if self.score > self.high_score:\n            self.high_score = self.score\n    \n    def food_consumed(self) -> None:\n        \"\"\"Record that food was consumed.\"\"\"\n        self.food_eaten += 1\n        self.add_points(10)\n    \n    def reset_score(self) -> None:\n        \"\"\"Reset the current game score.\"\"\"\n        self.score = 0\n        self.food_eaten = 0\n    \n    def get_score_text(self) -> str:\n        \"\"\"Get formatted score text.\"\"\"\n        return f\"Score: {self.score} | High Score: {self.high_score}\"",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__init__:163",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 163,
      "line_end": 166,
      "description": "Python method: __init__",
      "content": "def __init__(self):\n        self.score = 0\n        self.high_score = 0\n        self.food_eaten = 0",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "ScoreManager"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:add_points:168",
      "type": "method",
      "name": "add_points",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 168,
      "line_end": 172,
      "description": "Add points to the current score.",
      "content": "def add_points(self, points: int) -> None:\n        \"\"\"Add points to the current score.\"\"\"\n        self.score += points\n        if self.score > self.high_score:\n            self.high_score = self.score",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ScoreManager"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:food_consumed:174",
      "type": "method",
      "name": "food_consumed",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 174,
      "line_end": 177,
      "description": "Record that food was consumed.",
      "content": "def food_consumed(self) -> None:\n        \"\"\"Record that food was consumed.\"\"\"\n        self.food_eaten += 1\n        self.add_points(10)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ScoreManager"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:reset_score:179",
      "type": "method",
      "name": "reset_score",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 179,
      "line_end": 182,
      "description": "Reset the current game score.",
      "content": "def reset_score(self) -> None:\n        \"\"\"Reset the current game score.\"\"\"\n        self.score = 0\n        self.food_eaten = 0",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ScoreManager"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:get_score_text:184",
      "type": "method",
      "name": "get_score_text",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 184,
      "line_end": 186,
      "description": "Get formatted score text.",
      "content": "def get_score_text(self) -> str:\n        \"\"\"Get formatted score text.\"\"\"\n        return f\"Score: {self.score} | High Score: {self.high_score}\"",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ScoreManager"
      },
      "embedding": null
    },
    {
      "id": "class:game.py:GameRenderer:189",
      "type": "class",
      "name": "GameRenderer",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 189,
      "line_end": 232,
      "description": "Handles all game rendering operations.",
      "content": "class GameRenderer:\n    \"\"\"Handles all game rendering operations.\"\"\"\n    \n    def __init__(self, config: GameConfig):\n        self.config = config\n        pygame.init()\n        self.screen = pygame.display.set_mode((config.window_width, config.window_height))\n        pygame.display.set_caption(\"Snake Game\")\n        self.font = pygame.font.Font(None, 36)\n        self.clock = pygame.time.Clock()\n    \n    def clear_screen(self) -> None:\n        \"\"\"Clear the screen with background color.\"\"\"\n        self.screen.fill(self.config.background_color)\n    \n    def draw_text(self, text: str, position: Tuple[int, int], color: Tuple[int, int, int] = (255, 255, 255)) -> None:\n        \"\"\"Draw text on the screen.\"\"\"\n        text_surface = self.font.render(text, True, color)\n        self.screen.blit(text_surface, position)\n    \n    def draw_game_over(self, score_manager: ScoreManager) -> None:\n        \"\"\"Draw game over screen.\"\"\"\n        self.clear_screen()\n        \n        game_over_text = \"GAME OVER\"\n        score_text = score_manager.get_score_text()\n        restart_text = \"Press SPACE to restart or ESC to quit\"\n        \n        # Center the text\n        game_over_rect = self.font.get_rect(game_over_text)\n        score_rect = self.font.get_rect(score_text)\n        restart_rect = self.font.get_rect(restart_text)\n        \n        center_x = self.config.window_width // 2\n        center_y = self.config.window_height // 2\n        \n        self.draw_text(game_over_text, (center_x - game_over_rect.width // 2, center_y - 60), (255, 0, 0))\n        self.draw_text(score_text, (center_x - score_rect.width // 2, center_y))\n        self.draw_text(restart_text, (center_x - restart_rect.width // 2, center_y + 60))\n    \n    def update_display(self) -> None:\n        \"\"\"Update the display and maintain FPS.\"\"\"\n        pygame.display.flip()\n        self.clock.tick(self.config.fps)",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__init__:192",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 192,
      "line_end": 198,
      "description": "Python method: __init__",
      "content": "def __init__(self, config: GameConfig):\n        self.config = config\n        pygame.init()\n        self.screen = pygame.display.set_mode((config.window_width, config.window_height))\n        pygame.display.set_caption(\"Snake Game\")\n        self.font = pygame.font.Font(None, 36)\n        self.clock = pygame.time.Clock()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameRenderer"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:clear_screen:200",
      "type": "method",
      "name": "clear_screen",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 200,
      "line_end": 202,
      "description": "Clear the screen with background color.",
      "content": "def clear_screen(self) -> None:\n        \"\"\"Clear the screen with background color.\"\"\"\n        self.screen.fill(self.config.background_color)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameRenderer"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:draw_text:204",
      "type": "method",
      "name": "draw_text",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 204,
      "line_end": 207,
      "description": "Draw text on the screen.",
      "content": "def draw_text(self, text: str, position: Tuple[int, int], color: Tuple[int, int, int] = (255, 255, 255)) -> None:\n        \"\"\"Draw text on the screen.\"\"\"\n        text_surface = self.font.render(text, True, color)\n        self.screen.blit(text_surface, position)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameRenderer"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:draw_game_over:209",
      "type": "method",
      "name": "draw_game_over",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 209,
      "line_end": 227,
      "description": "Draw game over screen.",
      "content": "def draw_game_over(self, score_manager: ScoreManager) -> None:\n        \"\"\"Draw game over screen.\"\"\"\n        self.clear_screen()\n        \n        game_over_text = \"GAME OVER\"\n        score_text = score_manager.get_score_text()\n        restart_text = \"Press SPACE to restart or ESC to quit\"\n        \n        # Center the text\n        game_over_rect = self.font.get_rect(game_over_text)\n        score_rect = self.font.get_rect(score_text)\n        restart_rect = self.font.get_rect(restart_text)\n        \n        center_x = self.config.window_width // 2\n        center_y = self.config.window_height // 2\n        \n        self.draw_text(game_over_text, (center_x - game_over_rect.width // 2, center_y - 60), (255, 0, 0))\n        self.draw_text(score_text, (center_x - score_rect.width // 2, center_y))\n        self.draw_text(restart_text, (center_x - restart_rect.width // 2, center_y + 60))",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameRenderer"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:update_display:229",
      "type": "method",
      "name": "update_display",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 229,
      "line_end": 232,
      "description": "Update the display and maintain FPS.",
      "content": "def update_display(self) -> None:\n        \"\"\"Update the display and maintain FPS.\"\"\"\n        pygame.display.flip()\n        self.clock.tick(self.config.fps)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameRenderer"
      },
      "embedding": null
    },
    {
      "id": "class:game.py:InputHandler:235",
      "type": "class",
      "name": "InputHandler",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 235,
      "line_end": 274,
      "description": "Handles user input and events.",
      "content": "class InputHandler:\n    \"\"\"Handles user input and events.\"\"\"\n    \n    def __init__(self):\n        self.key_direction_map = {\n            pygame.K_UP: Direction.UP,\n            pygame.K_DOWN: Direction.DOWN,\n            pygame.K_LEFT: Direction.LEFT,\n            pygame.K_RIGHT: Direction.RIGHT,\n            pygame.K_w: Direction.UP,\n            pygame.K_s: Direction.DOWN,\n            pygame.K_a: Direction.LEFT,\n            pygame.K_d: Direction.RIGHT\n        }\n    \n    def handle_events(self, snake: Snake, game_state: GameState) -> Tuple[GameState, bool]:\n        \"\"\"Handle pygame events and return new game state and quit flag.\"\"\"\n        quit_game = False\n        \n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                quit_game = True\n            \n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_ESCAPE:\n                    quit_game = True\n                \n                elif event.key == pygame.K_SPACE:\n                    if game_state == GameState.GAME_OVER:\n                        game_state = GameState.PLAYING\n                    elif game_state == GameState.PLAYING:\n                        game_state = GameState.PAUSED\n                    elif game_state == GameState.PAUSED:\n                        game_state = GameState.PLAYING\n                \n                elif event.key in self.key_direction_map and game_state == GameState.PLAYING:\n                    new_direction = self.key_direction_map[event.key]\n                    snake.change_direction(new_direction)\n        \n        return game_state, quit_game",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__init__:238",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 238,
      "line_end": 248,
      "description": "Python method: __init__",
      "content": "def __init__(self):\n        self.key_direction_map = {\n            pygame.K_UP: Direction.UP,\n            pygame.K_DOWN: Direction.DOWN,\n            pygame.K_LEFT: Direction.LEFT,\n            pygame.K_RIGHT: Direction.RIGHT,\n            pygame.K_w: Direction.UP,\n            pygame.K_s: Direction.DOWN,\n            pygame.K_a: Direction.LEFT,\n            pygame.K_d: Direction.RIGHT\n        }",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "InputHandler"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:handle_events:250",
      "type": "method",
      "name": "handle_events",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 250,
      "line_end": 274,
      "description": "Handle pygame events and return new game state and quit flag.",
      "content": "def handle_events(self, snake: Snake, game_state: GameState) -> Tuple[GameState, bool]:\n        \"\"\"Handle pygame events and return new game state and quit flag.\"\"\"\n        quit_game = False\n        \n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                quit_game = True\n            \n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_ESCAPE:\n                    quit_game = True\n                \n                elif event.key == pygame.K_SPACE:\n                    if game_state == GameState.GAME_OVER:\n                        game_state = GameState.PLAYING\n                    elif game_state == GameState.PLAYING:\n                        game_state = GameState.PAUSED\n                    elif game_state == GameState.PAUSED:\n                        game_state = GameState.PLAYING\n                \n                elif event.key in self.key_direction_map and game_state == GameState.PLAYING:\n                    new_direction = self.key_direction_map[event.key]\n                    snake.change_direction(new_direction)\n        \n        return game_state, quit_game",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "InputHandler"
      },
      "embedding": null
    },
    {
      "id": "class:game.py:SnakeGame:277",
      "type": "class",
      "name": "SnakeGame",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 277,
      "line_end": 367,
      "description": "Main game class that orchestrates all components.",
      "content": "class SnakeGame:\n    \"\"\"Main game class that orchestrates all components.\"\"\"\n    \n    def __init__(self, config: Optional[GameConfig] = None):\n        self.config = config or GameConfig()\n        self.grid_width = self.config.window_width // self.config.grid_size\n        self.grid_height = self.config.window_height // self.config.grid_size\n        \n        # Initialize game components\n        self.renderer = GameRenderer(self.config)\n        self.input_handler = InputHandler()\n        self.score_manager = ScoreManager()\n        \n        # Initialize game objects\n        self.reset_game()\n        \n        self.game_state = GameState.PLAYING\n        self.running = True\n    \n    def reset_game(self) -> None:\n        \"\"\"Reset the game to initial state.\"\"\"\n        start_pos = Position(self.grid_width // 2, self.grid_height // 2)\n        self.snake = Snake(start_pos)\n        self.food = Food(self.grid_width, self.grid_height)\n        self.food.respawn(self.snake.get_body_positions())\n        self.score_manager.reset_score()\n    \n    def update_game_logic(self) -> None:\n        \"\"\"Update game logic for one frame.\"\"\"\n        if self.game_state != GameState.PLAYING:\n            return\n        \n        # Move snake\n        self.snake.move()\n        \n        # Check collisions\n        if (self.snake.check_collision_with_walls(self.grid_width, self.grid_height) or\n            self.snake.check_collision_with_self()):\n            self.game_state = GameState.GAME_OVER\n            return\n        \n        # Check food consumption\n        if self.snake.get_head_position() == self.food.position:\n            self.snake.grow()\n            self.score_manager.food_consumed()\n            self.food.respawn(self.snake.get_body_positions())\n    \n    def render_game(self) -> None:\n        \"\"\"Render the current game state.\"\"\"\n        if self.game_state == GameState.GAME_OVER:\n            self.renderer.draw_game_over(self.score_manager)\n        else:\n            self.renderer.clear_screen()\n            \n            # Draw game objects\n            self.food.draw(self.renderer.screen, self.config)\n            self.snake.draw(self.renderer.screen, self.config)\n            \n            # Draw UI\n            score_text = self.score_manager.get_score_text()\n            self.renderer.draw_text(score_text, (10, 10))\n            \n            if self.game_state == GameState.PAUSED:\n                pause_text = \"PAUSED - Press SPACE to continue\"\n                text_rect = self.renderer.font.get_rect(pause_text)\n                center_x = self.config.window_width // 2 - text_rect.width // 2\n                self.renderer.draw_text(pause_text, (center_x, 50), (255, 255, 0))\n        \n        self.renderer.update_display()\n    \n    def handle_input(self) -> None:\n        \"\"\"Handle user input.\"\"\"\n        new_state, quit_flag = self.input_handler.handle_events(self.snake, self.game_state)\n        \n        if quit_flag:\n            self.running = False\n        \n        if new_state == GameState.PLAYING and self.game_state == GameState.GAME_OVER:\n            self.reset_game()\n        \n        self.game_state = new_state\n    \n    def run(self) -> None:\n        \"\"\"Main game loop.\"\"\"\n        while self.running:\n            self.handle_input()\n            self.update_game_logic()\n            self.render_game()\n        \n        pygame.quit()\n        sys.exit()",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:game.py:__init__:280",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 280,
      "line_end": 294,
      "description": "Python method: __init__",
      "content": "def __init__(self, config: Optional[GameConfig] = None):\n        self.config = config or GameConfig()\n        self.grid_width = self.config.window_width // self.config.grid_size\n        self.grid_height = self.config.window_height // self.config.grid_size\n        \n        # Initialize game components\n        self.renderer = GameRenderer(self.config)\n        self.input_handler = InputHandler()\n        self.score_manager = ScoreManager()\n        \n        # Initialize game objects\n        self.reset_game()\n        \n        self.game_state = GameState.PLAYING\n        self.running = True",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "SnakeGame"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:reset_game:296",
      "type": "method",
      "name": "reset_game",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 296,
      "line_end": 302,
      "description": "Reset the game to initial state.",
      "content": "def reset_game(self) -> None:\n        \"\"\"Reset the game to initial state.\"\"\"\n        start_pos = Position(self.grid_width // 2, self.grid_height // 2)\n        self.snake = Snake(start_pos)\n        self.food = Food(self.grid_width, self.grid_height)\n        self.food.respawn(self.snake.get_body_positions())\n        self.score_manager.reset_score()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "SnakeGame"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:update_game_logic:304",
      "type": "method",
      "name": "update_game_logic",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 304,
      "line_end": 322,
      "description": "Update game logic for one frame.",
      "content": "def update_game_logic(self) -> None:\n        \"\"\"Update game logic for one frame.\"\"\"\n        if self.game_state != GameState.PLAYING:\n            return\n        \n        # Move snake\n        self.snake.move()\n        \n        # Check collisions\n        if (self.snake.check_collision_with_walls(self.grid_width, self.grid_height) or\n            self.snake.check_collision_with_self()):\n            self.game_state = GameState.GAME_OVER\n            return\n        \n        # Check food consumption\n        if self.snake.get_head_position() == self.food.position:\n            self.snake.grow()\n            self.score_manager.food_consumed()\n            self.food.respawn(self.snake.get_body_positions())",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "SnakeGame"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:render_game:324",
      "type": "method",
      "name": "render_game",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 324,
      "line_end": 345,
      "description": "Render the current game state.",
      "content": "def render_game(self) -> None:\n        \"\"\"Render the current game state.\"\"\"\n        if self.game_state == GameState.GAME_OVER:\n            self.renderer.draw_game_over(self.score_manager)\n        else:\n            self.renderer.clear_screen()\n            \n            # Draw game objects\n            self.food.draw(self.renderer.screen, self.config)\n            self.snake.draw(self.renderer.screen, self.config)\n            \n            # Draw UI\n            score_text = self.score_manager.get_score_text()\n            self.renderer.draw_text(score_text, (10, 10))\n            \n            if self.game_state == GameState.PAUSED:\n                pause_text = \"PAUSED - Press SPACE to continue\"\n                text_rect = self.renderer.font.get_rect(pause_text)\n                center_x = self.config.window_width // 2 - text_rect.width // 2\n                self.renderer.draw_text(pause_text, (center_x, 50), (255, 255, 0))\n        \n        self.renderer.update_display()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "SnakeGame"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:handle_input:347",
      "type": "method",
      "name": "handle_input",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 347,
      "line_end": 357,
      "description": "Handle user input.",
      "content": "def handle_input(self) -> None:\n        \"\"\"Handle user input.\"\"\"\n        new_state, quit_flag = self.input_handler.handle_events(self.snake, self.game_state)\n        \n        if quit_flag:\n            self.running = False\n        \n        if new_state == GameState.PLAYING and self.game_state == GameState.GAME_OVER:\n            self.reset_game()\n        \n        self.game_state = new_state",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "SnakeGame"
      },
      "embedding": null
    },
    {
      "id": "method:game.py:run:359",
      "type": "method",
      "name": "run",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 359,
      "line_end": 367,
      "description": "Main game loop.",
      "content": "def run(self) -> None:\n        \"\"\"Main game loop.\"\"\"\n        while self.running:\n            self.handle_input()\n            self.update_game_logic()\n            self.render_game()\n        \n        pygame.quit()\n        sys.exit()",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "SnakeGame"
      },
      "embedding": null
    },
    {
      "id": "function:game.py:main:370",
      "type": "function",
      "name": "main",
      "path": "/workspace/Coretx/examples/snake_game/game.py",
      "line_start": 370,
      "line_end": 384,
      "description": "Entry point for the snake game.",
      "content": "def main():\n    \"\"\"Entry point for the snake game.\"\"\"\n    # Create custom configuration if needed\n    config = GameConfig(\n        window_width=800,\n        window_height=600,\n        grid_size=20,\n        fps=12,\n        snake_color=(0, 255, 0),\n        food_color=(255, 0, 0)\n    )\n    \n    # Create and run the game\n    game = SnakeGame(config)\n    game.run()",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1",
      "type": "module",
      "name": "utils",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 1,
      "line_end": 210,
      "description": "Utility functions and helpers for the Snake Game.",
      "content": "\"\"\"\nUtility functions and helpers for the Snake Game.\n\"\"\"\n\nimport json\nimport os\nfrom typing import Dict, Any, List, Tuple\nfrom dataclasses import asdict\nfrom game import GameConfig, Position\n\n\nclass GameStats:\n    \"\"\"Tracks and manages game statistics.\"\"\"\n    \n    def __init__(self):\n        self.games_played = 0\n        self.total_score = 0\n        self.highest_score = 0\n        self.total_food_eaten = 0\n        self.average_game_length = 0.0\n        self.game_lengths = []\n    \n    def record_game(self, score: int, food_eaten: int, game_length: float) -> None:\n        \"\"\"Record statistics from a completed game.\"\"\"\n        self.games_played += 1\n        self.total_score += score\n        self.total_food_eaten += food_eaten\n        self.game_lengths.append(game_length)\n        \n        if score > self.highest_score:\n            self.highest_score = score\n        \n        self.average_game_length = sum(self.game_lengths) / len(self.game_lengths)\n    \n    def get_stats_dict(self) -> Dict[str, Any]:\n        \"\"\"Get statistics as a dictionary.\"\"\"\n        return {\n            \"games_played\": self.games_played,\n            \"total_score\": self.total_score,\n            \"highest_score\": self.highest_score,\n            \"total_food_eaten\": self.total_food_eaten,\n            \"average_score\": self.total_score / max(1, self.games_played),\n            \"average_game_length\": self.average_game_length\n        }\n    \n    def save_to_file(self, filename: str) -> None:\n        \"\"\"Save statistics to a JSON file.\"\"\"\n        with open(filename, 'w') as f:\n            json.dump(self.get_stats_dict(), f, indent=2)\n    \n    def load_from_file(self, filename: str) -> None:\n        \"\"\"Load statistics from a JSON file.\"\"\"\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                data = json.load(f)\n                self.games_played = data.get(\"games_played\", 0)\n                self.total_score = data.get(\"total_score\", 0)\n                self.highest_score = data.get(\"highest_score\", 0)\n                self.total_food_eaten = data.get(\"total_food_eaten\", 0)\n\n\nclass ConfigManager:\n    \"\"\"Manages game configuration loading and saving.\"\"\"\n    \n    @staticmethod\n    def save_config(config: GameConfig, filename: str) -> None:\n        \"\"\"Save game configuration to a JSON file.\"\"\"\n        config_dict = asdict(config)\n        with open(filename, 'w') as f:\n            json.dump(config_dict, f, indent=2)\n    \n    @staticmethod\n    def load_config(filename: str) -> GameConfig:\n        \"\"\"Load game configuration from a JSON file.\"\"\"\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                config_dict = json.load(f)\n                return GameConfig(**config_dict)\n        return GameConfig()\n\n\nclass PathFinder:\n    \"\"\"Utility class for pathfinding algorithms (for AI snake).\"\"\"\n    \n    @staticmethod\n    def manhattan_distance(pos1: Position, pos2: Position) -> int:\n        \"\"\"Calculate Manhattan distance between two positions.\"\"\"\n        return abs(pos1.x - pos2.x) + abs(pos1.y - pos2.y)\n    \n    @staticmethod\n    def get_neighbors(pos: Position, grid_width: int, grid_height: int) -> List[Position]:\n        \"\"\"Get valid neighboring positions.\"\"\"\n        neighbors = []\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for dx, dy in directions:\n            new_pos = Position(pos.x + dx, pos.y + dy)\n            if 0 <= new_pos.x < grid_width and 0 <= new_pos.y < grid_height:\n                neighbors.append(new_pos)\n        \n        return neighbors\n    \n    @staticmethod\n    def find_path_to_food(snake_head: Position, food_pos: Position, \n                         snake_body: List[Position], grid_width: int, \n                         grid_height: int) -> List[Position]:\n        \"\"\"Find a simple path from snake head to food using BFS.\"\"\"\n        from collections import deque\n        \n        queue = deque([(snake_head, [snake_head])])\n        visited = {snake_head}\n        \n        while queue:\n            current_pos, path = queue.popleft()\n            \n            if current_pos == food_pos:\n                return path[1:]  # Return path without starting position\n            \n            for neighbor in PathFinder.get_neighbors(current_pos, grid_width, grid_height):\n                if neighbor not in visited and neighbor not in snake_body:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return []  # No path found\n\n\nclass ColorUtils:\n    \"\"\"Utility functions for color manipulation.\"\"\"\n    \n    @staticmethod\n    def rgb_to_hex(rgb: Tuple[int, int, int]) -> str:\n        \"\"\"Convert RGB tuple to hex string.\"\"\"\n        return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\"\n    \n    @staticmethod\n    def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:\n        \"\"\"Convert hex string to RGB tuple.\"\"\"\n        hex_color = hex_color.lstrip('#')\n        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))\n    \n    @staticmethod\n    def interpolate_color(color1: Tuple[int, int, int], color2: Tuple[int, int, int], \n                         factor: float) -> Tuple[int, int, int]:\n        \"\"\"Interpolate between two colors.\"\"\"\n        factor = max(0, min(1, factor))\n        return tuple(\n            int(color1[i] + (color2[i] - color1[i]) * factor)\n            for i in range(3)\n        )\n\n\nclass GameValidator:\n    \"\"\"Validates game state and configuration.\"\"\"\n    \n    @staticmethod\n    def validate_config(config: GameConfig) -> List[str]:\n        \"\"\"Validate game configuration and return list of errors.\"\"\"\n        errors = []\n        \n        if config.window_width <= 0:\n            errors.append(\"Window width must be positive\")\n        \n        if config.window_height <= 0:\n            errors.append(\"Window height must be positive\")\n        \n        if config.grid_size <= 0:\n            errors.append(\"Grid size must be positive\")\n        \n        if config.fps <= 0:\n            errors.append(\"FPS must be positive\")\n        \n        if config.window_width % config.grid_size != 0:\n            errors.append(\"Window width must be divisible by grid size\")\n        \n        if config.window_height % config.grid_size != 0:\n            errors.append(\"Window height must be divisible by grid size\")\n        \n        return errors\n    \n    @staticmethod\n    def validate_position(pos: Position, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Validate if position is within grid bounds.\"\"\"\n        return 0 <= pos.x < grid_width and 0 <= pos.y < grid_height\n\n\ndef calculate_difficulty_multiplier(score: int) -> float:\n    \"\"\"Calculate difficulty multiplier based on current score.\"\"\"\n    base_multiplier = 1.0\n    score_threshold = 100\n    increment = 0.1\n    \n    return base_multiplier + (score // score_threshold) * increment\n\n\ndef format_time(seconds: float) -> str:\n    \"\"\"Format time in seconds to MM:SS format.\"\"\"\n    minutes = int(seconds // 60)\n    seconds = int(seconds % 60)\n    return f\"{minutes:02d}:{seconds:02d}\"\n\n\ndef generate_random_color() -> Tuple[int, int, int]:\n    \"\"\"Generate a random RGB color.\"\"\"\n    import random\n    return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))\n\n\ndef clamp(value: float, min_value: float, max_value: float) -> float:\n    \"\"\"Clamp a value between min and max.\"\"\"\n    return max(min_value, min(max_value, value))",
      "language": "python",
      "metadata": {
        "is_package": false,
        "line_count": 210
      },
      "embedding": null
    },
    {
      "id": "import:utils.py:import json:5",
      "type": "import",
      "name": "import json",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 5,
      "line_end": 5,
      "description": "",
      "content": "import json",
      "language": "python",
      "metadata": {
        "imported_names": [
          "json"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:utils.py:import os:6",
      "type": "import",
      "name": "import os",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 6,
      "line_end": 6,
      "description": "",
      "content": "import os",
      "language": "python",
      "metadata": {
        "imported_names": [
          "os"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:utils.py:import random:204",
      "type": "import",
      "name": "import random",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 204,
      "line_end": 204,
      "description": "",
      "content": "import random",
      "language": "python",
      "metadata": {
        "imported_names": [
          "random"
        ],
        "import_type": "import_statement"
      },
      "embedding": null
    },
    {
      "id": "import:utils.py:from typing import Dict, Any, List, Tuple:7",
      "type": "import",
      "name": "from typing import Dict, Any, List, Tuple",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 7,
      "line_end": 7,
      "description": "",
      "content": "from typing import Dict, Any, List, Tuple",
      "language": "python",
      "metadata": {
        "imported_names": [
          "Dict",
          "Any",
          "List",
          "Tuple"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:utils.py:from dataclasses import asdict:8",
      "type": "import",
      "name": "from dataclasses import asdict",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 8,
      "line_end": 8,
      "description": "",
      "content": "from dataclasses import asdict",
      "language": "python",
      "metadata": {
        "imported_names": [
          "asdict"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:utils.py:from game import GameConfig, Position:9",
      "type": "import",
      "name": "from game import GameConfig, Position",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 9,
      "line_end": 9,
      "description": "",
      "content": "from game import GameConfig, Position",
      "language": "python",
      "metadata": {
        "imported_names": [
          "GameConfig",
          "Position"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "import:utils.py:from collections import deque:108",
      "type": "import",
      "name": "from collections import deque",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 108,
      "line_end": 108,
      "description": "",
      "content": "from collections import deque",
      "language": "python",
      "metadata": {
        "imported_names": [
          "deque"
        ],
        "import_type": "import_from_statement"
      },
      "embedding": null
    },
    {
      "id": "class:utils.py:GameStats:12",
      "type": "class",
      "name": "GameStats",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 12,
      "line_end": 59,
      "description": "Tracks and manages game statistics.",
      "content": "class GameStats:\n    \"\"\"Tracks and manages game statistics.\"\"\"\n    \n    def __init__(self):\n        self.games_played = 0\n        self.total_score = 0\n        self.highest_score = 0\n        self.total_food_eaten = 0\n        self.average_game_length = 0.0\n        self.game_lengths = []\n    \n    def record_game(self, score: int, food_eaten: int, game_length: float) -> None:\n        \"\"\"Record statistics from a completed game.\"\"\"\n        self.games_played += 1\n        self.total_score += score\n        self.total_food_eaten += food_eaten\n        self.game_lengths.append(game_length)\n        \n        if score > self.highest_score:\n            self.highest_score = score\n        \n        self.average_game_length = sum(self.game_lengths) / len(self.game_lengths)\n    \n    def get_stats_dict(self) -> Dict[str, Any]:\n        \"\"\"Get statistics as a dictionary.\"\"\"\n        return {\n            \"games_played\": self.games_played,\n            \"total_score\": self.total_score,\n            \"highest_score\": self.highest_score,\n            \"total_food_eaten\": self.total_food_eaten,\n            \"average_score\": self.total_score / max(1, self.games_played),\n            \"average_game_length\": self.average_game_length\n        }\n    \n    def save_to_file(self, filename: str) -> None:\n        \"\"\"Save statistics to a JSON file.\"\"\"\n        with open(filename, 'w') as f:\n            json.dump(self.get_stats_dict(), f, indent=2)\n    \n    def load_from_file(self, filename: str) -> None:\n        \"\"\"Load statistics from a JSON file.\"\"\"\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                data = json.load(f)\n                self.games_played = data.get(\"games_played\", 0)\n                self.total_score = data.get(\"total_score\", 0)\n                self.highest_score = data.get(\"highest_score\", 0)\n                self.total_food_eaten = data.get(\"total_food_eaten\", 0)",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:__init__:15",
      "type": "method",
      "name": "__init__",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 15,
      "line_end": 21,
      "description": "Python method: __init__",
      "content": "def __init__(self):\n        self.games_played = 0\n        self.total_score = 0\n        self.highest_score = 0\n        self.total_food_eaten = 0\n        self.average_game_length = 0.0\n        self.game_lengths = []",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": true,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameStats"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:record_game:23",
      "type": "method",
      "name": "record_game",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 23,
      "line_end": 33,
      "description": "Record statistics from a completed game.",
      "content": "def record_game(self, score: int, food_eaten: int, game_length: float) -> None:\n        \"\"\"Record statistics from a completed game.\"\"\"\n        self.games_played += 1\n        self.total_score += score\n        self.total_food_eaten += food_eaten\n        self.game_lengths.append(game_length)\n        \n        if score > self.highest_score:\n            self.highest_score = score\n        \n        self.average_game_length = sum(self.game_lengths) / len(self.game_lengths)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameStats"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:get_stats_dict:35",
      "type": "method",
      "name": "get_stats_dict",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 35,
      "line_end": 44,
      "description": "Get statistics as a dictionary.",
      "content": "def get_stats_dict(self) -> Dict[str, Any]:\n        \"\"\"Get statistics as a dictionary.\"\"\"\n        return {\n            \"games_played\": self.games_played,\n            \"total_score\": self.total_score,\n            \"highest_score\": self.highest_score,\n            \"total_food_eaten\": self.total_food_eaten,\n            \"average_score\": self.total_score / max(1, self.games_played),\n            \"average_game_length\": self.average_game_length\n        }",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameStats"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:save_to_file:46",
      "type": "method",
      "name": "save_to_file",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 46,
      "line_end": 49,
      "description": "Save statistics to a JSON file.",
      "content": "def save_to_file(self, filename: str) -> None:\n        \"\"\"Save statistics to a JSON file.\"\"\"\n        with open(filename, 'w') as f:\n            json.dump(self.get_stats_dict(), f, indent=2)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameStats"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:load_from_file:51",
      "type": "method",
      "name": "load_from_file",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 51,
      "line_end": 59,
      "description": "Load statistics from a JSON file.",
      "content": "def load_from_file(self, filename: str) -> None:\n        \"\"\"Load statistics from a JSON file.\"\"\"\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                data = json.load(f)\n                self.games_played = data.get(\"games_played\", 0)\n                self.total_score = data.get(\"total_score\", 0)\n                self.highest_score = data.get(\"highest_score\", 0)\n                self.total_food_eaten = data.get(\"total_food_eaten\", 0)",
      "language": "python",
      "metadata": {
        "parameters": [
          {
            "name": "self",
            "type": null,
            "default": null
          }
        ],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameStats"
      },
      "embedding": null
    },
    {
      "id": "class:utils.py:ConfigManager:62",
      "type": "class",
      "name": "ConfigManager",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 62,
      "line_end": 79,
      "description": "Manages game configuration loading and saving.",
      "content": "class ConfigManager:\n    \"\"\"Manages game configuration loading and saving.\"\"\"\n    \n    @staticmethod\n    def save_config(config: GameConfig, filename: str) -> None:\n        \"\"\"Save game configuration to a JSON file.\"\"\"\n        config_dict = asdict(config)\n        with open(filename, 'w') as f:\n            json.dump(config_dict, f, indent=2)\n    \n    @staticmethod\n    def load_config(filename: str) -> GameConfig:\n        \"\"\"Load game configuration from a JSON file.\"\"\"\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                config_dict = json.load(f)\n                return GameConfig(**config_dict)\n        return GameConfig()",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:save_config:66",
      "type": "method",
      "name": "save_config",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 66,
      "line_end": 70,
      "description": "Save game configuration to a JSON file.",
      "content": "def save_config(config: GameConfig, filename: str) -> None:\n        \"\"\"Save game configuration to a JSON file.\"\"\"\n        config_dict = asdict(config)\n        with open(filename, 'w') as f:\n            json.dump(config_dict, f, indent=2)",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ConfigManager"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:load_config:73",
      "type": "method",
      "name": "load_config",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 73,
      "line_end": 79,
      "description": "Load game configuration from a JSON file.",
      "content": "def load_config(filename: str) -> GameConfig:\n        \"\"\"Load game configuration from a JSON file.\"\"\"\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                config_dict = json.load(f)\n                return GameConfig(**config_dict)\n        return GameConfig()",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ConfigManager"
      },
      "embedding": null
    },
    {
      "id": "class:utils.py:PathFinder:82",
      "type": "class",
      "name": "PathFinder",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 82,
      "line_end": 124,
      "description": "Utility class for pathfinding algorithms (for AI snake).",
      "content": "class PathFinder:\n    \"\"\"Utility class for pathfinding algorithms (for AI snake).\"\"\"\n    \n    @staticmethod\n    def manhattan_distance(pos1: Position, pos2: Position) -> int:\n        \"\"\"Calculate Manhattan distance between two positions.\"\"\"\n        return abs(pos1.x - pos2.x) + abs(pos1.y - pos2.y)\n    \n    @staticmethod\n    def get_neighbors(pos: Position, grid_width: int, grid_height: int) -> List[Position]:\n        \"\"\"Get valid neighboring positions.\"\"\"\n        neighbors = []\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for dx, dy in directions:\n            new_pos = Position(pos.x + dx, pos.y + dy)\n            if 0 <= new_pos.x < grid_width and 0 <= new_pos.y < grid_height:\n                neighbors.append(new_pos)\n        \n        return neighbors\n    \n    @staticmethod\n    def find_path_to_food(snake_head: Position, food_pos: Position, \n                         snake_body: List[Position], grid_width: int, \n                         grid_height: int) -> List[Position]:\n        \"\"\"Find a simple path from snake head to food using BFS.\"\"\"\n        from collections import deque\n        \n        queue = deque([(snake_head, [snake_head])])\n        visited = {snake_head}\n        \n        while queue:\n            current_pos, path = queue.popleft()\n            \n            if current_pos == food_pos:\n                return path[1:]  # Return path without starting position\n            \n            for neighbor in PathFinder.get_neighbors(current_pos, grid_width, grid_height):\n                if neighbor not in visited and neighbor not in snake_body:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return []  # No path found",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:manhattan_distance:86",
      "type": "method",
      "name": "manhattan_distance",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 86,
      "line_end": 88,
      "description": "Calculate Manhattan distance between two positions.",
      "content": "def manhattan_distance(pos1: Position, pos2: Position) -> int:\n        \"\"\"Calculate Manhattan distance between two positions.\"\"\"\n        return abs(pos1.x - pos2.x) + abs(pos1.y - pos2.y)",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "PathFinder"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:get_neighbors:91",
      "type": "method",
      "name": "get_neighbors",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 91,
      "line_end": 101,
      "description": "Get valid neighboring positions.",
      "content": "def get_neighbors(pos: Position, grid_width: int, grid_height: int) -> List[Position]:\n        \"\"\"Get valid neighboring positions.\"\"\"\n        neighbors = []\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for dx, dy in directions:\n            new_pos = Position(pos.x + dx, pos.y + dy)\n            if 0 <= new_pos.x < grid_width and 0 <= new_pos.y < grid_height:\n                neighbors.append(new_pos)\n        \n        return neighbors",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "PathFinder"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:find_path_to_food:104",
      "type": "method",
      "name": "find_path_to_food",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 104,
      "line_end": 124,
      "description": "Find a simple path from snake head to food using BFS.",
      "content": "def find_path_to_food(snake_head: Position, food_pos: Position, \n                         snake_body: List[Position], grid_width: int, \n                         grid_height: int) -> List[Position]:\n        \"\"\"Find a simple path from snake head to food using BFS.\"\"\"\n        from collections import deque\n        \n        queue = deque([(snake_head, [snake_head])])\n        visited = {snake_head}\n        \n        while queue:\n            current_pos, path = queue.popleft()\n            \n            if current_pos == food_pos:\n                return path[1:]  # Return path without starting position\n            \n            for neighbor in PathFinder.get_neighbors(current_pos, grid_width, grid_height):\n                if neighbor not in visited and neighbor not in snake_body:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return []  # No path found",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "PathFinder"
      },
      "embedding": null
    },
    {
      "id": "class:utils.py:ColorUtils:127",
      "type": "class",
      "name": "ColorUtils",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 127,
      "line_end": 149,
      "description": "Utility functions for color manipulation.",
      "content": "class ColorUtils:\n    \"\"\"Utility functions for color manipulation.\"\"\"\n    \n    @staticmethod\n    def rgb_to_hex(rgb: Tuple[int, int, int]) -> str:\n        \"\"\"Convert RGB tuple to hex string.\"\"\"\n        return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\"\n    \n    @staticmethod\n    def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:\n        \"\"\"Convert hex string to RGB tuple.\"\"\"\n        hex_color = hex_color.lstrip('#')\n        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))\n    \n    @staticmethod\n    def interpolate_color(color1: Tuple[int, int, int], color2: Tuple[int, int, int], \n                         factor: float) -> Tuple[int, int, int]:\n        \"\"\"Interpolate between two colors.\"\"\"\n        factor = max(0, min(1, factor))\n        return tuple(\n            int(color1[i] + (color2[i] - color1[i]) * factor)\n            for i in range(3)\n        )",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:rgb_to_hex:131",
      "type": "method",
      "name": "rgb_to_hex",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 131,
      "line_end": 133,
      "description": "Convert RGB tuple to hex string.",
      "content": "def rgb_to_hex(rgb: Tuple[int, int, int]) -> str:\n        \"\"\"Convert RGB tuple to hex string.\"\"\"\n        return f\"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}\"",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ColorUtils"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:hex_to_rgb:136",
      "type": "method",
      "name": "hex_to_rgb",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 136,
      "line_end": 139,
      "description": "Convert hex string to RGB tuple.",
      "content": "def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:\n        \"\"\"Convert hex string to RGB tuple.\"\"\"\n        hex_color = hex_color.lstrip('#')\n        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ColorUtils"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:interpolate_color:142",
      "type": "method",
      "name": "interpolate_color",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 142,
      "line_end": 149,
      "description": "Interpolate between two colors.",
      "content": "def interpolate_color(color1: Tuple[int, int, int], color2: Tuple[int, int, int], \n                         factor: float) -> Tuple[int, int, int]:\n        \"\"\"Interpolate between two colors.\"\"\"\n        factor = max(0, min(1, factor))\n        return tuple(\n            int(color1[i] + (color2[i] - color1[i]) * factor)\n            for i in range(3)\n        )",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "ColorUtils"
      },
      "embedding": null
    },
    {
      "id": "class:utils.py:GameValidator:152",
      "type": "class",
      "name": "GameValidator",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 152,
      "line_end": 183,
      "description": "Validates game state and configuration.",
      "content": "class GameValidator:\n    \"\"\"Validates game state and configuration.\"\"\"\n    \n    @staticmethod\n    def validate_config(config: GameConfig) -> List[str]:\n        \"\"\"Validate game configuration and return list of errors.\"\"\"\n        errors = []\n        \n        if config.window_width <= 0:\n            errors.append(\"Window width must be positive\")\n        \n        if config.window_height <= 0:\n            errors.append(\"Window height must be positive\")\n        \n        if config.grid_size <= 0:\n            errors.append(\"Grid size must be positive\")\n        \n        if config.fps <= 0:\n            errors.append(\"FPS must be positive\")\n        \n        if config.window_width % config.grid_size != 0:\n            errors.append(\"Window width must be divisible by grid size\")\n        \n        if config.window_height % config.grid_size != 0:\n            errors.append(\"Window height must be divisible by grid size\")\n        \n        return errors\n    \n    @staticmethod\n    def validate_position(pos: Position, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Validate if position is within grid bounds.\"\"\"\n        return 0 <= pos.x < grid_width and 0 <= pos.y < grid_height",
      "language": "python",
      "metadata": {
        "base_classes": [],
        "decorators": [],
        "is_abstract": false
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:validate_config:156",
      "type": "method",
      "name": "validate_config",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 156,
      "line_end": 178,
      "description": "Validate game configuration and return list of errors.",
      "content": "def validate_config(config: GameConfig) -> List[str]:\n        \"\"\"Validate game configuration and return list of errors.\"\"\"\n        errors = []\n        \n        if config.window_width <= 0:\n            errors.append(\"Window width must be positive\")\n        \n        if config.window_height <= 0:\n            errors.append(\"Window height must be positive\")\n        \n        if config.grid_size <= 0:\n            errors.append(\"Grid size must be positive\")\n        \n        if config.fps <= 0:\n            errors.append(\"FPS must be positive\")\n        \n        if config.window_width % config.grid_size != 0:\n            errors.append(\"Window width must be divisible by grid size\")\n        \n        if config.window_height % config.grid_size != 0:\n            errors.append(\"Window height must be divisible by grid size\")\n        \n        return errors",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameValidator"
      },
      "embedding": null
    },
    {
      "id": "method:utils.py:validate_position:181",
      "type": "method",
      "name": "validate_position",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 181,
      "line_end": 183,
      "description": "Validate if position is within grid bounds.",
      "content": "def validate_position(pos: Position, grid_width: int, grid_height: int) -> bool:\n        \"\"\"Validate if position is within grid bounds.\"\"\"\n        return 0 <= pos.x < grid_width and 0 <= pos.y < grid_height",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [
          "@staticmethod"
        ],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": "GameValidator"
      },
      "embedding": null
    },
    {
      "id": "function:utils.py:calculate_difficulty_multiplier:186",
      "type": "function",
      "name": "calculate_difficulty_multiplier",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 186,
      "line_end": 192,
      "description": "Calculate difficulty multiplier based on current score.",
      "content": "def calculate_difficulty_multiplier(score: int) -> float:\n    \"\"\"Calculate difficulty multiplier based on current score.\"\"\"\n    base_multiplier = 1.0\n    score_threshold = 100\n    increment = 0.1\n    \n    return base_multiplier + (score // score_threshold) * increment",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "function:utils.py:format_time:195",
      "type": "function",
      "name": "format_time",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 195,
      "line_end": 199,
      "description": "Format time in seconds to MM:SS format.",
      "content": "def format_time(seconds: float) -> str:\n    \"\"\"Format time in seconds to MM:SS format.\"\"\"\n    minutes = int(seconds // 60)\n    seconds = int(seconds % 60)\n    return f\"{minutes:02d}:{seconds:02d}\"",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "function:utils.py:generate_random_color:202",
      "type": "function",
      "name": "generate_random_color",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 202,
      "line_end": 205,
      "description": "Generate a random RGB color.",
      "content": "def generate_random_color() -> Tuple[int, int, int]:\n    \"\"\"Generate a random RGB color.\"\"\"\n    import random\n    return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    },
    {
      "id": "function:utils.py:clamp:208",
      "type": "function",
      "name": "clamp",
      "path": "/workspace/Coretx/examples/snake_game/utils.py",
      "line_start": 208,
      "line_end": 210,
      "description": "Clamp a value between min and max.",
      "content": "def clamp(value: float, min_value: float, max_value: float) -> float:\n    \"\"\"Clamp a value between min and max.\"\"\"\n    return max(min_value, min(max_value, value))",
      "language": "python",
      "metadata": {
        "parameters": [],
        "decorators": [],
        "is_special": false,
        "is_private": false,
        "is_property": false,
        "parent_class": null
      },
      "embedding": null
    }
  ],
  "relationships": [
    {
      "id": "module:ai_player.py:ai_player:1->contains->import:ai_player.py:import random:6",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "import:ai_player.py:import random:6",
      "description": "Module contains import: import random",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->import:ai_player.py:from typing import List, Optional, Tuple:7",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "import:ai_player.py:from typing import List, Optional, Tuple:7",
      "description": "Module contains import: from typing import List, Optional, Tuple",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->import:ai_player.py:from enum import Enum:8",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "import:ai_player.py:from enum import Enum:8",
      "description": "Module contains import: from enum import Enum",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->import:ai_player.py:from game import Snake, Food, Direction, Position:9",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "import:ai_player.py:from game import Snake, Food, Direction, Position:9",
      "description": "Module contains import: from game import Snake, Food, Direction, Position",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->import:ai_player.py:from utils import PathFinder:10",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "import:ai_player.py:from utils import PathFinder:10",
      "description": "Module contains import: from utils import PathFinder",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AdvancedAI:202->inherits->class:ai_player.py:AIPlayer:21",
      "type": "inherits",
      "source_id": "class:ai_player.py:AdvancedAI:202",
      "target_id": "class:ai_player.py:AIPlayer:21",
      "description": "AdvancedAI inherits from AIPlayer",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->class:ai_player.py:AIStrategy:13",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "class:ai_player.py:AIStrategy:13",
      "description": "Module contains class: AIStrategy",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->class:ai_player.py:AIPlayer:21",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "class:ai_player.py:AIPlayer:21",
      "description": "Module contains class: AIPlayer",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->class:ai_player.py:AdvancedAI:202",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "class:ai_player.py:AdvancedAI:202",
      "description": "Module contains class: AdvancedAI",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:ai_player.py:ai_player:1->contains->function:ai_player.py:create_ai_player:262",
      "type": "contains",
      "source_id": "module:ai_player.py:ai_player:1",
      "target_id": "function:ai_player.py:create_ai_player:262",
      "description": "Module contains function: create_ai_player",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:__init__:24",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:__init__:24",
      "description": "Class AIPlayer contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:get_next_move:29",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:get_next_move:29",
      "description": "Class AIPlayer contains method: get_next_move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:_random_move:44",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:_random_move:44",
      "description": "Class AIPlayer contains method: _random_move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:_greedy_move:62",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:_greedy_move:62",
      "description": "Class AIPlayer contains method: _greedy_move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:_pathfinding_move:111",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:_pathfinding_move:111",
      "description": "Class AIPlayer contains method: _pathfinding_move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:_hamiltonian_move:126",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:_hamiltonian_move:126",
      "description": "Class AIPlayer contains method: _hamiltonian_move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:_is_safe_move:152",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:_is_safe_move:152",
      "description": "Class AIPlayer contains method: _is_safe_move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:_get_direction_to_position:170",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:_get_direction_to_position:170",
      "description": "Class AIPlayer contains method: _get_direction_to_position",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:get_performance_stats:186",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:get_performance_stats:186",
      "description": "Class AIPlayer contains method: get_performance_stats",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AIPlayer:21->contains->method:ai_player.py:reset_stats:196",
      "type": "contains",
      "source_id": "class:ai_player.py:AIPlayer:21",
      "target_id": "method:ai_player.py:reset_stats:196",
      "description": "Class AIPlayer contains method: reset_stats",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AdvancedAI:202->contains->method:ai_player.py:__init__:205",
      "type": "contains",
      "source_id": "class:ai_player.py:AdvancedAI:202",
      "target_id": "method:ai_player.py:__init__:205",
      "description": "Class AdvancedAI contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AdvancedAI:202->contains->method:ai_player.py:get_next_move:215",
      "type": "contains",
      "source_id": "class:ai_player.py:AdvancedAI:202",
      "target_id": "method:ai_player.py:get_next_move:215",
      "description": "Class AdvancedAI contains method: get_next_move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AdvancedAI:202->contains->method:ai_player.py:record_game_result:225",
      "type": "contains",
      "source_id": "class:ai_player.py:AdvancedAI:202",
      "target_id": "method:ai_player.py:record_game_result:225",
      "description": "Class AdvancedAI contains method: record_game_result",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AdvancedAI:202->contains->method:ai_player.py:_adapt_strategy:235",
      "type": "contains",
      "source_id": "class:ai_player.py:AdvancedAI:202",
      "target_id": "method:ai_player.py:_adapt_strategy:235",
      "description": "Class AdvancedAI contains method: _adapt_strategy",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:ai_player.py:AdvancedAI:202->contains->method:ai_player.py:get_strategy_stats:249",
      "type": "contains",
      "source_id": "class:ai_player.py:AdvancedAI:202",
      "target_id": "method:ai_player.py:get_strategy_stats:249",
      "description": "Class AdvancedAI contains method: get_strategy_stats",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:import argparse:6",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:import argparse:6",
      "description": "Module contains import: import argparse",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:import sys:7",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:import sys:7",
      "description": "Module contains import: import sys",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:import time:8",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:import time:8",
      "description": "Module contains import: import time",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:import pygame:69",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:import pygame:69",
      "description": "Module contains import: import pygame",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:import pygame:123",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:import pygame:123",
      "description": "Module contains import: import pygame",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:from typing import Optional:9",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:from typing import Optional:9",
      "description": "Module contains import: from typing import Optional",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:from game import SnakeGame, GameConfig:10",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:from game import SnakeGame, GameConfig:10",
      "description": "Module contains import: from game import SnakeGame, GameConfig",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:from ai_player import create_ai_player, AIStrategy:11",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:from ai_player import create_ai_player, AIStrategy:11",
      "description": "Module contains import: from ai_player import create_ai_player, AIStrategy",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->import:main.py:from utils import GameStats, ConfigManager:12",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "import:main.py:from utils import GameStats, ConfigManager:12",
      "description": "Module contains import: from utils import GameStats, ConfigManager",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->function:main.py:run_human_game:15",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "function:main.py:run_human_game:15",
      "description": "Module contains function: run_human_game",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->function:main.py:run_ai_game:24",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "function:main.py:run_ai_game:24",
      "description": "Module contains function: run_ai_game",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->function:main.py:run_benchmark:91",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "function:main.py:run_benchmark:91",
      "description": "Module contains function: run_benchmark",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->function:main.py:create_config_from_args:145",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "function:main.py:create_config_from_args:145",
      "description": "Module contains function: create_config_from_args",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:main.py:main:1->contains->function:main.py:main:161",
      "type": "contains",
      "source_id": "module:main.py:main:1",
      "target_id": "function:main.py:main:161",
      "description": "Module contains function: main",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->import:game.py:import pygame:6",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "import:game.py:import pygame:6",
      "description": "Module contains import: import pygame",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->import:game.py:import random:7",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "import:game.py:import random:7",
      "description": "Module contains import: import random",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->import:game.py:import sys:8",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "import:game.py:import sys:8",
      "description": "Module contains import: import sys",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->import:game.py:from enum import Enum:9",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "import:game.py:from enum import Enum:9",
      "description": "Module contains import: from enum import Enum",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->import:game.py:from typing import List, Tuple, Optional:10",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "import:game.py:from typing import List, Tuple, Optional:10",
      "description": "Module contains import: from typing import List, Tuple, Optional",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->import:game.py:from dataclasses import dataclass:11",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "import:game.py:from dataclasses import dataclass:11",
      "description": "Module contains import: from dataclasses import dataclass",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:Direction:14",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:Direction:14",
      "description": "Module contains class: Direction",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:GameState:22",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:GameState:22",
      "description": "Module contains class: GameState",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:Position:30",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:Position:30",
      "description": "Module contains class: Position",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:GameConfig:43",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:GameConfig:43",
      "description": "Module contains class: GameConfig",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:Food:55",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:Food:55",
      "description": "Module contains class: Food",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:Snake:87",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:Snake:87",
      "description": "Module contains class: Snake",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:ScoreManager:160",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:ScoreManager:160",
      "description": "Module contains class: ScoreManager",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:GameRenderer:189",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:GameRenderer:189",
      "description": "Module contains class: GameRenderer",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:InputHandler:235",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:InputHandler:235",
      "description": "Module contains class: InputHandler",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->class:game.py:SnakeGame:277",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "class:game.py:SnakeGame:277",
      "description": "Module contains class: SnakeGame",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:game.py:game:1->contains->function:game.py:main:370",
      "type": "contains",
      "source_id": "module:game.py:game:1",
      "target_id": "function:game.py:main:370",
      "description": "Module contains function: main",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Position:30->contains->method:game.py:__add__:35",
      "type": "contains",
      "source_id": "class:game.py:Position:30",
      "target_id": "method:game.py:__add__:35",
      "description": "Class Position contains method: __add__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Position:30->contains->method:game.py:__eq__:38",
      "type": "contains",
      "source_id": "class:game.py:Position:30",
      "target_id": "method:game.py:__eq__:38",
      "description": "Class Position contains method: __eq__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Food:55->contains->method:game.py:__init__:58",
      "type": "contains",
      "source_id": "class:game.py:Food:55",
      "target_id": "method:game.py:__init__:58",
      "description": "Class Food contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Food:55->contains->method:game.py:_generate_position:63",
      "type": "contains",
      "source_id": "class:game.py:Food:55",
      "target_id": "method:game.py:_generate_position:63",
      "description": "Class Food contains method: _generate_position",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Food:55->contains->method:game.py:respawn:69",
      "type": "contains",
      "source_id": "class:game.py:Food:55",
      "target_id": "method:game.py:respawn:69",
      "description": "Class Food contains method: respawn",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Food:55->contains->method:game.py:draw:76",
      "type": "contains",
      "source_id": "class:game.py:Food:55",
      "target_id": "method:game.py:draw:76",
      "description": "Class Food contains method: draw",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:__init__:90",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:__init__:90",
      "description": "Class Snake contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:move:96",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:move:96",
      "description": "Class Snake contains method: move",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:change_direction:111",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:change_direction:111",
      "description": "Class Snake contains method: change_direction",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:grow:124",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:grow:124",
      "description": "Class Snake contains method: grow",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:check_collision_with_self:128",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:check_collision_with_self:128",
      "description": "Class Snake contains method: check_collision_with_self",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:check_collision_with_walls:133",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:check_collision_with_walls:133",
      "description": "Class Snake contains method: check_collision_with_walls",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:get_head_position:139",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:get_head_position:139",
      "description": "Class Snake contains method: get_head_position",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:get_body_positions:143",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:get_body_positions:143",
      "description": "Class Snake contains method: get_body_positions",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:Snake:87->contains->method:game.py:draw:147",
      "type": "contains",
      "source_id": "class:game.py:Snake:87",
      "target_id": "method:game.py:draw:147",
      "description": "Class Snake contains method: draw",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:ScoreManager:160->contains->method:game.py:__init__:163",
      "type": "contains",
      "source_id": "class:game.py:ScoreManager:160",
      "target_id": "method:game.py:__init__:163",
      "description": "Class ScoreManager contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:ScoreManager:160->contains->method:game.py:add_points:168",
      "type": "contains",
      "source_id": "class:game.py:ScoreManager:160",
      "target_id": "method:game.py:add_points:168",
      "description": "Class ScoreManager contains method: add_points",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:ScoreManager:160->contains->method:game.py:food_consumed:174",
      "type": "contains",
      "source_id": "class:game.py:ScoreManager:160",
      "target_id": "method:game.py:food_consumed:174",
      "description": "Class ScoreManager contains method: food_consumed",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:ScoreManager:160->contains->method:game.py:reset_score:179",
      "type": "contains",
      "source_id": "class:game.py:ScoreManager:160",
      "target_id": "method:game.py:reset_score:179",
      "description": "Class ScoreManager contains method: reset_score",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:ScoreManager:160->contains->method:game.py:get_score_text:184",
      "type": "contains",
      "source_id": "class:game.py:ScoreManager:160",
      "target_id": "method:game.py:get_score_text:184",
      "description": "Class ScoreManager contains method: get_score_text",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:GameRenderer:189->contains->method:game.py:__init__:192",
      "type": "contains",
      "source_id": "class:game.py:GameRenderer:189",
      "target_id": "method:game.py:__init__:192",
      "description": "Class GameRenderer contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:GameRenderer:189->contains->method:game.py:clear_screen:200",
      "type": "contains",
      "source_id": "class:game.py:GameRenderer:189",
      "target_id": "method:game.py:clear_screen:200",
      "description": "Class GameRenderer contains method: clear_screen",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:GameRenderer:189->contains->method:game.py:draw_text:204",
      "type": "contains",
      "source_id": "class:game.py:GameRenderer:189",
      "target_id": "method:game.py:draw_text:204",
      "description": "Class GameRenderer contains method: draw_text",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:GameRenderer:189->contains->method:game.py:draw_game_over:209",
      "type": "contains",
      "source_id": "class:game.py:GameRenderer:189",
      "target_id": "method:game.py:draw_game_over:209",
      "description": "Class GameRenderer contains method: draw_game_over",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:GameRenderer:189->contains->method:game.py:update_display:229",
      "type": "contains",
      "source_id": "class:game.py:GameRenderer:189",
      "target_id": "method:game.py:update_display:229",
      "description": "Class GameRenderer contains method: update_display",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:InputHandler:235->contains->method:game.py:__init__:238",
      "type": "contains",
      "source_id": "class:game.py:InputHandler:235",
      "target_id": "method:game.py:__init__:238",
      "description": "Class InputHandler contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:InputHandler:235->contains->method:game.py:handle_events:250",
      "type": "contains",
      "source_id": "class:game.py:InputHandler:235",
      "target_id": "method:game.py:handle_events:250",
      "description": "Class InputHandler contains method: handle_events",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:SnakeGame:277->contains->method:game.py:__init__:280",
      "type": "contains",
      "source_id": "class:game.py:SnakeGame:277",
      "target_id": "method:game.py:__init__:280",
      "description": "Class SnakeGame contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:SnakeGame:277->contains->method:game.py:reset_game:296",
      "type": "contains",
      "source_id": "class:game.py:SnakeGame:277",
      "target_id": "method:game.py:reset_game:296",
      "description": "Class SnakeGame contains method: reset_game",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:SnakeGame:277->contains->method:game.py:update_game_logic:304",
      "type": "contains",
      "source_id": "class:game.py:SnakeGame:277",
      "target_id": "method:game.py:update_game_logic:304",
      "description": "Class SnakeGame contains method: update_game_logic",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:SnakeGame:277->contains->method:game.py:render_game:324",
      "type": "contains",
      "source_id": "class:game.py:SnakeGame:277",
      "target_id": "method:game.py:render_game:324",
      "description": "Class SnakeGame contains method: render_game",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:SnakeGame:277->contains->method:game.py:handle_input:347",
      "type": "contains",
      "source_id": "class:game.py:SnakeGame:277",
      "target_id": "method:game.py:handle_input:347",
      "description": "Class SnakeGame contains method: handle_input",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:game.py:SnakeGame:277->contains->method:game.py:run:359",
      "type": "contains",
      "source_id": "class:game.py:SnakeGame:277",
      "target_id": "method:game.py:run:359",
      "description": "Class SnakeGame contains method: run",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->import:utils.py:import json:5",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "import:utils.py:import json:5",
      "description": "Module contains import: import json",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->import:utils.py:import os:6",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "import:utils.py:import os:6",
      "description": "Module contains import: import os",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->import:utils.py:import random:204",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "import:utils.py:import random:204",
      "description": "Module contains import: import random",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->import:utils.py:from typing import Dict, Any, List, Tuple:7",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "import:utils.py:from typing import Dict, Any, List, Tuple:7",
      "description": "Module contains import: from typing import Dict, Any, List, Tuple",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->import:utils.py:from dataclasses import asdict:8",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "import:utils.py:from dataclasses import asdict:8",
      "description": "Module contains import: from dataclasses import asdict",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->import:utils.py:from game import GameConfig, Position:9",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "import:utils.py:from game import GameConfig, Position:9",
      "description": "Module contains import: from game import GameConfig, Position",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->import:utils.py:from collections import deque:108",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "import:utils.py:from collections import deque:108",
      "description": "Module contains import: from collections import deque",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->class:utils.py:GameStats:12",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "class:utils.py:GameStats:12",
      "description": "Module contains class: GameStats",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->class:utils.py:ConfigManager:62",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "class:utils.py:ConfigManager:62",
      "description": "Module contains class: ConfigManager",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->class:utils.py:PathFinder:82",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "class:utils.py:PathFinder:82",
      "description": "Module contains class: PathFinder",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->class:utils.py:ColorUtils:127",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "class:utils.py:ColorUtils:127",
      "description": "Module contains class: ColorUtils",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->class:utils.py:GameValidator:152",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "class:utils.py:GameValidator:152",
      "description": "Module contains class: GameValidator",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->function:utils.py:calculate_difficulty_multiplier:186",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "function:utils.py:calculate_difficulty_multiplier:186",
      "description": "Module contains function: calculate_difficulty_multiplier",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->function:utils.py:format_time:195",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "function:utils.py:format_time:195",
      "description": "Module contains function: format_time",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->function:utils.py:generate_random_color:202",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "function:utils.py:generate_random_color:202",
      "description": "Module contains function: generate_random_color",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "module:utils.py:utils:1->contains->function:utils.py:clamp:208",
      "type": "contains",
      "source_id": "module:utils.py:utils:1",
      "target_id": "function:utils.py:clamp:208",
      "description": "Module contains function: clamp",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:GameStats:12->contains->method:utils.py:__init__:15",
      "type": "contains",
      "source_id": "class:utils.py:GameStats:12",
      "target_id": "method:utils.py:__init__:15",
      "description": "Class GameStats contains method: __init__",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:GameStats:12->contains->method:utils.py:record_game:23",
      "type": "contains",
      "source_id": "class:utils.py:GameStats:12",
      "target_id": "method:utils.py:record_game:23",
      "description": "Class GameStats contains method: record_game",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:GameStats:12->contains->method:utils.py:get_stats_dict:35",
      "type": "contains",
      "source_id": "class:utils.py:GameStats:12",
      "target_id": "method:utils.py:get_stats_dict:35",
      "description": "Class GameStats contains method: get_stats_dict",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:GameStats:12->contains->method:utils.py:save_to_file:46",
      "type": "contains",
      "source_id": "class:utils.py:GameStats:12",
      "target_id": "method:utils.py:save_to_file:46",
      "description": "Class GameStats contains method: save_to_file",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:GameStats:12->contains->method:utils.py:load_from_file:51",
      "type": "contains",
      "source_id": "class:utils.py:GameStats:12",
      "target_id": "method:utils.py:load_from_file:51",
      "description": "Class GameStats contains method: load_from_file",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:ConfigManager:62->contains->method:utils.py:save_config:66",
      "type": "contains",
      "source_id": "class:utils.py:ConfigManager:62",
      "target_id": "method:utils.py:save_config:66",
      "description": "Class ConfigManager contains method: save_config",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:ConfigManager:62->contains->method:utils.py:load_config:73",
      "type": "contains",
      "source_id": "class:utils.py:ConfigManager:62",
      "target_id": "method:utils.py:load_config:73",
      "description": "Class ConfigManager contains method: load_config",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:PathFinder:82->contains->method:utils.py:manhattan_distance:86",
      "type": "contains",
      "source_id": "class:utils.py:PathFinder:82",
      "target_id": "method:utils.py:manhattan_distance:86",
      "description": "Class PathFinder contains method: manhattan_distance",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:PathFinder:82->contains->method:utils.py:get_neighbors:91",
      "type": "contains",
      "source_id": "class:utils.py:PathFinder:82",
      "target_id": "method:utils.py:get_neighbors:91",
      "description": "Class PathFinder contains method: get_neighbors",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:PathFinder:82->contains->method:utils.py:find_path_to_food:104",
      "type": "contains",
      "source_id": "class:utils.py:PathFinder:82",
      "target_id": "method:utils.py:find_path_to_food:104",
      "description": "Class PathFinder contains method: find_path_to_food",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:ColorUtils:127->contains->method:utils.py:rgb_to_hex:131",
      "type": "contains",
      "source_id": "class:utils.py:ColorUtils:127",
      "target_id": "method:utils.py:rgb_to_hex:131",
      "description": "Class ColorUtils contains method: rgb_to_hex",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:ColorUtils:127->contains->method:utils.py:hex_to_rgb:136",
      "type": "contains",
      "source_id": "class:utils.py:ColorUtils:127",
      "target_id": "method:utils.py:hex_to_rgb:136",
      "description": "Class ColorUtils contains method: hex_to_rgb",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:ColorUtils:127->contains->method:utils.py:interpolate_color:142",
      "type": "contains",
      "source_id": "class:utils.py:ColorUtils:127",
      "target_id": "method:utils.py:interpolate_color:142",
      "description": "Class ColorUtils contains method: interpolate_color",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:GameValidator:152->contains->method:utils.py:validate_config:156",
      "type": "contains",
      "source_id": "class:utils.py:GameValidator:152",
      "target_id": "method:utils.py:validate_config:156",
      "description": "Class GameValidator contains method: validate_config",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    },
    {
      "id": "class:utils.py:GameValidator:152->contains->method:utils.py:validate_position:181",
      "type": "contains",
      "source_id": "class:utils.py:GameValidator:152",
      "target_id": "method:utils.py:validate_position:181",
      "description": "Class GameValidator contains method: validate_position",
      "metadata": {},
      "confidence": 1.0,
      "embedding": null
    }
  ]
}